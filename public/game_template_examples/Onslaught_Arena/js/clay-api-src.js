// Generated by CoffeeScript 1.5.0
(function() {
  var local, _base,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  local = {};

  if (typeof window.Clay === 'undefined') {
    window.Clay = {};
    local.loadNow = false;
  } else {
    local.loadNow = true;
  }

  /*
  local.loadNow = false
  */


  Clay.PROTOCOL || (Clay.PROTOCOL = (document && document.location && ('https:' === document.location.protocol || 'chrome-extension:' === document.location.protocol || 'ms-appx:' === document.location.protocol) ? 'https://' : 'http://'));

  Clay.BASEURL || (Clay.BASEURL = Clay.PROTOCOL + 'clay.io');

  Clay.DOMAIN || (Clay.DOMAIN = 'clay.io');

  if (!Clay.SOCKET_ADDRESS) {
    if (Clay.PROTOCOL === 'https://') {
      Clay.SOCKET_PORT = 846;
      Clay.SOCKET_ADDRESS = Clay.PROTOCOL + Clay.DOMAIN + ':' + Clay.SOCKET_PORT;
    } else {
      Clay.SOCKET_PORT = 80;
      Clay.SOCKET_ADDRESS = Clay.PROTOCOL + 'socket.' + Clay.DOMAIN;
    }
  }

  Clay.options || (Clay.options = {
    debug: false
  });

  Clay.readyFunctions || (Clay.readyFunctions = []);

  Clay.windows8 = false;

  if (navigator.userAgent.indexOf('MSAppHost') !== -1) {
    (_base = Clay.options).noExternal || (_base.noExternal = true);
    Clay.windows8 = true;
  }

  Clay.orientation = window.orientation;

  Clay.source = true;

  local.Callbacks = (function() {

    function Callbacks() {}

    Callbacks.callbacks = {};

    Callbacks.add = function(fn) {
      var id;
      if (typeof fn === 'function') {
        id = Math.random();
        this.callbacks[id] = {
          fn: fn,
          obj: arguments.callee
        };
        return id;
      }
      return false;
    };

    Callbacks.execute = function(id, args) {
      var cb;
      if (args == null) {
        args = [];
      }
      if (id && this.callbacks[id]) {
        cb = this.callbacks[id];
        cb.fn.apply(cb.obj, args);
        return delete this.callbacks[id];
      }
    };

    return Callbacks;

  })();

  this.namespace = function(target, name, block) {
    var item, top, _i, _len, _ref, _ref1;
    if (arguments.length < 3) {
      _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
    }
    top = target;
    _ref1 = name.split('.');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      target = target[item] || (target[item] = {});
    }
    return block(target, top);
  };

  namespace('Clay', function(exports) {
    exports.log = function(msg) {
      if (typeof console !== 'undefined') {
        // return console.log(msg);
        return undefined;
      }
    };
    local.DOMLoaded = false;
    local.ready = (function() {
      var contentLoaded, fns, ready, scrollCheck, toplevel, w3c;
      exports.log("Local Ready Called");
      contentLoaded = function() {
        if (w3c) {
          document.removeEventListener("DOMContentLoaded", contentLoaded, true);
        } else if (document.readyState === "complete") {
          document.detachEvent("onreadystatechange", contentLoaded);
        }
        return ready();
      };
      scrollCheck = function() {
        if (local.DOMLoaded) {
          return;
        }
        try {
          document.documentElement.doScroll("left");
        } catch (e) {
          window.setTimeout(arguments_.callee, 15);
          return;
        }
        return ready();
      };
      ready = function() {
        var i, len, _results;
        if (local.DOMLoaded) {
          return;
        }
        local.DOMLoaded = true;
        len = fns.length;
        i = 0;
        _results = [];
        while (i < len) {
          exports.log("Local Ready Fired");
          fns[i].call(document);
          _results.push(i++);
        }
        return _results;
      };
      w3c = !!document.addEventListener;
      local.DOMLoaded = false;
      toplevel = false;
      fns = [];
      if (document.readyState === "complete" || document.readySate === "loaded") {
        ready();
      } else if (w3c) {
        document.addEventListener("DOMContentLoaded", contentLoaded, true);
        window.addEventListener("load", ready, false);
      } else {
        document.attachEvent("onreadystatechange", contentLoaded);
        window.attachEvent("onload", ready);
        try {
          toplevel = window.frameElement === null;
        } catch (_error) {}
        if (document.documentElement.doScroll && toplevel) {
          scrollCheck();
        }
      }
      return function(fn) {
        if (local.DOMLoaded) {
          return fn.call(document);
        } else {
          return fns.push(fn);
        }
      };
    })();
    exports.passToNode = function(json) {
      var load;
      load = function(json) {
        if (exports.loaded) {
          return local.Events.socketEmit('user', 'login', json);
        } else {
          return setTimeout(function() {
            return load(json);
          }, 100);
        }
      };
      load(json);
      return local.removeJsonp('passToNode');
    };
    local.jsonp = function(action, params, callback) {
      var script, tag;
      if (!exports.options.noExternal) {
        script = document.createElement("script");
        script.type = 'text/javascript';
        script.src = Clay.BASEURL + '/ajax/' + action + '?time=' + new Date().getTime() + '&callback=Clay.' + callback + "&" + local.objToParams(params);
        script.id = 'clay-callback-' + callback;
        tag = document.getElementsByTagName("script")[0];
        return tag.parentNode.insertBefore(script, tag);
      }
    };
    local.objToParams = function(obj) {
      var p, url;
      url = [];
      for (p in obj) {
        if (obj.hasOwnProperty(p)) {
          url.push(p + "=" + encodeURIComponent(obj[p]));
        }
      }
      return url.join("&");
    };
    local.removeJsonp = function(callbackName) {
      var ele;
      ele = document.getElementById('clay-callback-' + callbackName);
      if (ele) {
        return ele.parentNode.removeChild(ele);
      }
    };
    return local.htmlEntities = function(str) {
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    };
  });

  namespace('Clay', function(exports) {
    return exports.User = (function() {
      /*
      		Contains methods for anything related to the current user (player) of your game
      		[Click here](http://clay.io/docs/player) for our Article Page on Players
      */

      function User() {
        this.loggedIn = false;
        this.clearance = 'site';
        this.installed = false;
        this.identifier = 0;
        this.callbacks = [];
        this.localStorageChecked = false;
      }

      User.prototype.socketListen = function() {
        return local.Events.socketListen('user', this, null, false);
      };

      User.prototype.setUsername = function(username) {
        /*
        			Gives the player a custom name, instead of Anonymous if they're not logged into Clay.io. By default, the user is able to choose this in the Clay login modal
        			@param [required] (string) username The name you want to give them (will show up on things like leaderboards)
        */

        var sendObj;
        sendObj = {
          username: username
        };
        return local.Events.socketEmit('user', sendObj);
      };

      User.prototype.hasRated = function() {};

      User.prototype.saveUserData = function(dataKey, data, callback) {
        var callbackId, options;
        if (callback == null) {
          callback = false;
        }
        /*
        			Saves the specified saved user data to the server
        			Note: you cannot save data under the keys "user", "game", or "_id"
        			Usage: User.saveUserData('level1Score', '51000', function( response ) { console.log( response.success ); }  ... $ true
        			@param (string) key the key that you'd like to save the data to
        			@param (object) data JSON-safe data for saving
        			@param [optional] (function) callback Called when user data is saved
        				@arg (object) response Contains response data
        					@option (string) error null if no error
        					@option (boolean) success true if data successfully saved
        					@option (multi) data contains the data you just saved
        					@option (string) key contains the key that you just saved data under
        */

        callbackId = local.Callbacks.add(callback);
        options = {
          dataKey: dataKey,
          data: data
        };
        return local.Events.socketEmit('user', 'saveUserData', options, false, callbackId);
      };

      User.prototype.saveUserDataCallback = function(response, callbackId) {
        return local.Callbacks.execute(callbackId, [response]);
      };

      User.prototype.fetchUserData = function(key, callback) {
        var callbackId, options;
        if (callback == null) {
          callback = false;
        }
        /*
        			Grabs the specified saved user data from the server
        			Usage: User.fetchUserData('level1Score', function( repsonse) { console.log( response.data ); } )  ... $ '51000'
        			@param (string) key the key specifying the data you'd like to fetch
        			@param [optional] (function) callback Called when user data is received from server
        				@arg (object) response Contains response data
        					@option (string) error null if no error
        					@option (multi) data contains the data you just requested
        					@option (string) key contains the key that you just requested data for
        */

        callbackId = local.Callbacks.add(callback);
        options = {
          dataKey: key
        };
        return local.Events.socketEmit('user', 'fetchUserData', options, false, callbackId);
      };

      User.prototype.fetchUserDataCallback = function(response, callbackId) {
        return local.Callbacks.execute(callbackId, [response]);
      };

      User.storeUserData = function(dataKey, data, callback) {
        if (callback == null) {
          callback = false;
        }
        localStorage['clayData'] || (localStorage['clayData'] = {});
        localStorage['clayData'][dataKey] = data;
        return callback({
          success: true,
          key: dataKey
        });
      };

      User.fetchUserDataLocal = function(key, callback) {
        var data;
        if (callback == null) {
          callback = false;
        }
        data = localStorage['clayData'] || {};
        return callback({
          success: true,
          key: key,
          data: [dataKey]
        });
      };

      User.prototype.fetchItems = function(callback) {
        /*
        			Grabs all the items this player has in your game
        			@param [required] (function) callback
        				@arg (array) items An array of item ids they have
        */

        var callbackId;
        callbackId = local.Callbacks.add(callback);
        return local.Events.socketEmit('user', 'fetchItems', {}, false, callbackId);
      };

      User.prototype.fetchItemsCallback = function(data, callbackId) {
        return local.Callbacks.execute(callbackId, [data]);
      };

      User.prototype.grantItem = function(options, callback) {
        var callbackId;
        if (callback == null) {
          callback = false;
        }
        /*
        			Grants the user an item (created in the developer dashboard for your game)
        			@param [optional] (object) options
        				@option (int) id The item's id (given to you after creating it)
        				@option (int) quantity How many of the item you want to give
        			@param [optional] (function) callback Called when item is granted
        				@arg (array) response An object with the following properties
        					@property (int) id The item's id
        					@property (int) quantity How many were given
        */

        callbackId = local.Callbacks.add(callback);
        return local.Events.socketEmit('user', 'grantItem', options, false, callbackId);
      };

      User.prototype.grantItemCallback = function(data, callbackId) {
        if (!data.error) {
          exports.UI.createNotification({
            title: 'Item Granted!',
            html: 'You just got ' + data.quantity + ': ' + data.item.name + '!'
          });
        }
        return local.Callbacks.execute(callbackId, [data]);
      };

      User.prototype.removeItem = function(options, callback) {
        var callbackId;
        if (callback == null) {
          callback = false;
        }
        /*
        			Removes an item from the player's inventory
        			@param [optional] (object) options
        				@option (int) id The item's id (given to you after creating it)
        				@option (int) quantity How many of the item you want to remove - pass 'all' to remove all of this item
        			@param [optional] (function) callback Called when item is removed
        				@arg (array) response An object with the following properties
        					@property (int) id The item's id
        					@property (int) quantity How many were removed
        */

        callbackId = local.Callbacks.add(callback);
        return local.Events.socketEmit('user', 'removeItem', options, false, callbackId);
      };

      User.prototype.removeItemCallback = function(data, callbackId) {
        return local.Callbacks.execute(callbackId, [data]);
      };

      User.prototype.purchaseGame = function(callback) {
        /*
        			If this isn't a free game, let them buy the game from within your game
        			This is equivalent to adding an item with type: 'game', id: gameID, and calling checkout
        			@param [optional] (function) callback Called when either purchase has successfully gone through, or if there was an error/canceled process
        				@arg (object) response
        					@property (bool) success True if the user went through the whole process without generating an error
        					@property (truthy) error Boolean false if no error, String error message if error
        					@property (string) status Info about the payments current status (ex. pending) - this still needs to be normalized on our end. Give us a nudge if we haven't done it yet
        					@property (bool) completed Boolean if the payment was approved right away or not
        					@property (array) itemIds Array of Integers: The items they ended up purchasing - this could be different than the items you pass since they can optionally remove items
        */

        var pay;
        pay = new exports.Payment();
        return pay.addItem({
          type: 'game',
          id: exports.gameID
        }, function() {
          return pay.checkout(callback);
        });
      };

      User.prototype.hasInstalled = function() {
        /*
        			@return (boolean) installed If the user has "installed" (or purchased if it's not a free game) the game or not
        */
        return this.installed;
      };

      User.prototype.getName = function() {
        return this.data['name'] || this.data['username'];
      };

      User.prototype.onUserReady = function(callback) {
        /*
        			Called when the user is logged in (and we have a name for them)
        			@param [optional] (function) callback Called when the user has logged in (or entered their name)
        				@arg (object) response
        					@property (string) identifier A unique identifier associated with the user
        */
        if (this.identifier) {
          return callback({
            name: this.getName(),
            identifier: this.identifier
          });
        } else {
          return this.userReadyCallback = callback;
        }
      };

      User.prototype.doLogin = function(obj) {
        var callbackId, id, json, _ref;
        exports.log("Clay.io is ready");
        /*
        			if @loginButton
        				if obj.error
        					alert obj.error
        					@loginButton.value = 'Try again!'
        				else	
        					@loginButton.value = 'Success!'
        					if exports.UI.canvasInput.inputs
        						for input in exports.UI.canvasInput.inputs
        							input.destroy()
        						exports.UI.canvasInput.inputs = [] # reset
        					exports.UI.removeElement exports.UI.canvas
        				@loginButton.refresh()
        */

        if (obj.success) {
          this.clearance = obj.clearance;
          this.installed = obj.installed || false;
          this.identifier = obj.identifier || 'no-identifier';
          this.loggedIn = true;
          this.data = obj.data;
          if (this.userReadyCallback) {
            this.userReadyCallback({
              identifier: this.identifier,
              name: this.getName()
            });
          }
          _ref = this.callbacks;
          for (id in _ref) {
            callbackId = _ref[id];
            local.Callbacks.execute(callbackId, [
              {
                success: true,
                error: false
              }
            ]);
          }
          if (this.successfulJSON && this.clearance === 'clay') {
            localStorage.setItem('clayLogin', JSON.stringify(this.successfulJSON));
          }
          if (obj.fromPrompt) {
            exports.UI.closeModal('clay-login-wrapper', false);
          }
        } else if (obj.loginPrompt) {
          if (!this.localStorageChecked && (json = localStorage.getItem('clayLogin'))) {
            json = JSON.parse(json);
            this.sendLogin(json);
            this.localStorageChecked = true;
          } else {
            this.login();
          }
        } else if (obj.error) {
          exports.log(obj.error);
        }
        return local.callReadies();
      };

      User.prototype.login = function(options, callback, signup) {
        var ele, handler, listenCallback, loginHTML, modalOptions, params, signupTmp,
          _this = this;
        if (options == null) {
          options = {};
        }
        if (callback == null) {
          callback = false;
        }
        if (signup == null) {
          signup = false;
        }
        /*
        			Manually triggers the flow for a user to login, signup, or enter their name within the modal window
        			@param [optional] (object) options
        				@option (string) id Specify if you do not want to use the standard Clay.io UI. Pass the DOM element ID you want the login box to go in
        			@param [optional] (function) callback Called when either the login was successful, or if there was an error/canceled process
        				@arg (object) response
        					@property (bool) success True if the user logged in successfully
        					@property (truthy) error Boolean false if no error, String error message if error
        			@param [optional] (boolean) signup If set to true, the signup tab is opened initially (rather than login)
        */

        if (typeof options !== 'object') {
          signupTmp = callback;
          callback = options;
          options = signup;
          signup = signupTmp;
        }
        if (callback) {
          this.callbacks.push(local.Callbacks.add(callback));
        }
        /*
        			exports.UI.setCanvas( document.getElementById( exports.options.canvas ), =>
        				exports.UI.ctx.clearRect 0, 0, exports.canvasWidth, exports.canvasHeight
        				logo = new Image()
        				logo.src = exports.BASEURL + '/images/logo.svg'
        				logo.onload = ->
        					exports.UI.ctx.drawImage( logo, exports.UI.canvasWidth / 2 - 70, 10, 141, 100 )
        				if @signupFirst # just used for demo canvasinput page (blog post)
        					@showSignupCanvas()
        				else
        					@showLoginCanvas()
        			)
        */

        loginHTML = [];
        params = [];
        if (signup) {
          params.push('signup');
        }
        if (options.requireLogin) {
          params.push('require');
        }
        ele = document.getElementById('clay-login-wrapper');
        modalOptions = {
          title: (signup ? 'Signup' : 'Login'),
          html: loginHTML,
          id: 'clay-login-wrapper',
          iframe: {
            src: exports.BASEURL + "/api/login/" + exports.gameKey + '?' + params.join('&'),
            id: 'clay-login-iframe',
            "class": "clay-" + (signup ? 'signup' : 'login') + "-iframe"
          },
          DOMid: options.id
        };
        if (!ele || ele.style.display === 'none') {
          exports.UI.createModal(modalOptions);
        }
        handler = function() {
          var callbackId, id, _ref, _ref1, _results, _results1;
          if (!exports.Game.data.forceSignup && !options.requireLogin && !_this.loggedIn) {
            return _this.sendLogin({
              name: 'Anonymous'
            });
          } else if (!_this.loggedIn) {
            _ref = _this.callbacks;
            _results = [];
            for (id in _ref) {
              callbackId = _ref[id];
              _results.push(local.Callbacks.execute(callbackId, [
                {
                  success: false,
                  error: "Not logged in"
                }
              ]));
            }
            return _results;
          } else {
            _ref1 = _this.callbacks;
            _results1 = [];
            for (id in _ref1) {
              callbackId = _ref1[id];
              _results1.push(local.Callbacks.execute(callbackId, [
                {
                  success: true,
                  error: false
                }
              ]));
            }
            return _results1;
          }
        };
        local.Events.addEvent('closemodal', handler, false, true, document.getElementById(modalOptions.id));
        listenCallback = function(event) {
          var json;
          if (~exports.BASEURL.indexOf(event.origin)) {
            json = JSON.parse(event.data);
            if (json.openCocoonJSLink) {
              return CocoonJS.App.openURL(openCocoonJSLink);
            } else if (json.popup) {
              return exports.UI.showPopupNotifier(json.popup);
            } else if (json.popupClose) {
              return exports.UI.hidePopupNotifier(json.popupClose);
            } else if (json.height) {
              ele = document.getElementById('clay-login-iframe');
              if (ele) {
                ele.style.height = json.height + "px";
              }
              return exports.UI.centerModal('clay-login-wrapper');
            } else {
              _this.sendLogin(json);
              exports.UI.closeModal('clay-login-wrapper', false);
              return local.Events.removeEvent('message', arguments.callee);
            }
          }
        };
        return local.Events.addEvent('message', listenCallback);
      };

      /*
      		canvasLogin: ->
      			@loginButton.value = 'Loading...'
      			@loginButton.refresh()
      			@sendLogin( { username: @usernameInput.value, unhashedPassword: @passwordInput.value } )
      			
      		canvasSignup: ->
      			@loginButton.value = 'Loading...'
      			@loginButton.refresh()
      			sendObj = { username: @usernameInput.value, unhashedPassword: @passwordInput.value, email: @emailInput.value }
      			local.Events.socketEmit( 'user', 'signup', sendObj )
      			exports.log "Signing up..."
      			
      		showLoginCanvas: ->
      			@loginCanvas = true
      			@signupCanvas = false
      			if exports.UI.canvasInput.inputs
      				for input in exports.UI.canvasInput.inputs
      					input.destroy()
      				exports.UI.canvasInput.inputs = [] # reset
      			exports.UI.ctx.clearRect 0, 120, exports.UI.canvasWidth, exports.UI.canvasHeight - 120
      			@usernameInput = new exports.UI.canvasText exports.UI.canvas, { x: 0, y: 120, id: 'username', placeholder: 'Enter your username...' }
      			@passwordInput = new exports.UI.canvasPassword exports.UI.canvas, { x: 0, y: 155, id: 'password', placeholder: 'Enter your password...' }
      			@loginButton = new exports.UI.canvasSubmit exports.UI.canvas, { x: 0, y: 195, id: 'login', placeholder: 'Login', onClick: (-> exports.Player.canvasLogin()) }
      			guestLink = new exports.UI.canvasSubmit exports.UI.canvas, { x: 0, y: 230, id: 'guest', placeholder: 'Login as Guest', onClick: (=> @sendLogin( { name: 'Anonymous' } )) }
      			signupLink = new exports.UI.canvasSubmit exports.UI.canvas, { x: 0, y: 265, id: 'signup', placeholder: 'Not a member?', onClick: (=> @showSignupCanvas()) }
      		showSignupCanvas: ->
      			@loginCanvas = false
      			@signupCanvas = true
      			if exports.UI.canvasInput.inputs
      				for input in exports.UI.canvasInput.inputs
      					input.destroy()
      				exports.UI.canvasInput.inputs = [] # reset
      			exports.UI.ctx.clearRect 0, 120, exports.UI.canvasWidth, exports.UI.canvasHeight - 120
      			@usernameInput = new exports.UI.canvasText exports.UI.canvas, { x: 0, y: 120, id: 'username', placeholder: 'Enter your username...' }
      			@passwordInput = new exports.UI.canvasPassword exports.UI.canvas, { x: 0, y: 155, id: 'password', placeholder: 'Enter your password...' }
      			@emailInput = new exports.UI.canvasText exports.UI.canvas, { x: 0, y: 190, id: 'email', placeholder: 'Enter your email...' }
      			@loginButton = new exports.UI.canvasSubmit exports.UI.canvas, { x: 0, y: 230, id: 'signup', placeholder: 'Signup', onClick: (-> exports.Player.canvasSignup()) }
      			signupLink = new exports.UI.canvasSubmit exports.UI.canvas, { x: 0, y: 265, id: 'login', placeholder: 'Already a member?', onClick: (=> @showLoginCanvas()) }
      		
      		signupCallback: (obj) ->
      			if obj.errors
      				for error, msg of obj.errors
      					alert error.charAt(0).toUpperCase() + error.substr(1) + ": " + msg
      				
      				if @loginButton
      						@loginButton.value = 'Try again!'
      					else	
      						@loginButton.value = 'Success!'
      						if exports.UI.canvasInput.inputs
      							for input in exports.UI.canvasInput.inputs
      								input.destroy()
      							exports.UI.canvasInput.inputs = [] # reset
      					@loginButton.refresh()
      */


      User.prototype.signup = function(callback, options) {
        if (options == null) {
          options = {};
        }
        /*
        			Manually triggers the flow for a user to signup, within the modal window. Alias for Clay.Player.login( callback, true );
        			@param [optional] (function) callback Called when either the login was successful, or if there was an error/canceled process
        				@arg (object) response
        					@property (bool) success True if the user signed up in successfully
        					@property (truthy) error Boolean false if no error, String error message if error
        */

        return this.login(callback, true, options);
      };

      User.prototype.sendLogin = function(json) {
        var sendObj;
        if (json.identifier) {
          this.identifier = json.identifier;
        }
        if (json.hash) {
          sendObj = {
            fromPrompt: true,
            hash: json.hash,
            identifier: json.identifier
          };
        } else {
          sendObj = {
            fromPrompt: true,
            username: json.name
          };
        }
        /*
        			if json.unhashedPassword # (for domless)
        				sendObj = { username: json.username, unhashedPassword: json.unhashedPassword }
        */

        this.successfulJSON = json;
        local.Events.socketEmit('user', 'login', sendObj);
        return exports.log("Logging in...");
      };

      User.prototype.requireLogin = function(callback, reqLoggedIntoClay) {
        if (callback == null) {
          callback = false;
        }
        if (reqLoggedIntoClay == null) {
          reqLoggedIntoClay = false;
        }
        /*
        			Does a check if they're logged in - calls the callback if they are, 
        			forces them to login if they aren't (then calls the callback after login)
        			Use this for anything is your game where you need the user to be logged in
        			@param [required] (function) callback Called immediately if the user is logged in, or where they login otherwise
        			@param [optional] (boolean) requireLoggedIntoClay Set true if you only want this called if they are logged into a clay.io account (ie they aren't anonymously 'logged in' with just their name)
        */

        if (this.loggedIn && (!reqLoggedIntoClay || this.clearance === 'clay')) {
          return callback({
            success: true,
            error: false
          });
        } else {
          if (callback) {
            this.callbacks.push(local.Callbacks.add(callback));
          }
          return this.login(false, false, {
            requireLogin: reqLoggedIntoClay
          });
        }
      };

      return User;

    })();
  });

  namespace('Clay', function(exports) {
    var handler;
    local.Events = (function() {

      function Events() {}

      Events.groups = {};

      Events.addEvent = function(type, listener, useObject, removeListener, obj, removeGroup) {
        var tmp,
          _this = this;
        if (useObject == null) {
          useObject = false;
        }
        if (removeListener == null) {
          removeListener = false;
        }
        if (obj == null) {
          obj = window;
        }
        if (removeGroup == null) {
          removeGroup = false;
        }
        if (removeListener || removeGroup !== false) {
          tmp = listener;
          listener = function(event) {
            var group, remove, _i, _len, _ref;
            remove = tmp(event);
            if (remove !== 'skipRemoval' && removeGroup !== false && _this.groups[removeGroup]) {
              _ref = _this.groups[removeGroup];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                group = _ref[_i];
                _this.removeEvent(group.type, group.listener, group.useObject, group.obj);
              }
              return delete _this.groups[removeGroup];
            } else if (remove !== 'skipRemoval' && removeListener) {
              return _this.removeEvent(type, arguments.callee, useObject, obj);
            }
          };
          if (removeGroup !== false) {
            if (!this.groups[removeGroup]) {
              this.groups[removeGroup] = [];
            }
            this.groups[removeGroup].push({
              type: type,
              listener: listener,
              useObject: useObject,
              obj: obj
            });
          }
        }
        if (obj.addEventListener) {
          return obj.addEventListener(type, listener, useObject);
        } else if (obj.attachEvent) {
          return obj.attachEvent('on' + type, listener, useObject);
        } else {
          return obj['on' + type] = listener;
        }
      };

      Events.removeEvent = function(type, listener, useObject, obj) {
        if (useObject == null) {
          useObject = false;
        }
        if (obj == null) {
          obj = window;
        }
        if (obj.removeEventListener) {
          return obj.removeEventListener(type, listener, useObject);
        } else if (obj.detachEvent) {
          return obj.detachEvent('on' + type, listener, useObject);
        } else {
          return obj['on' + type] = null;
        }
      };

      Events.triggerEvent = function(name, element) {
        var event;
        if (element == null) {
          element = window;
        }
        event = void 0;
        if (document.createEvent) {
          event = document.createEvent("HTMLEvents");
          event.initEvent(name, true, true);
        } else {
          event = document.createEventObject();
          event.eventType = "on" + name;
        }
        event.eventName = name;
        if (document.createEvent) {
          return element.dispatchEvent(event);
        } else {
          return element.fireEvent(event.eventType, event);
        }
      };

      Events.socketListen = function(type, listener, method, removeListener) {
        var broadcastType, handler, _this;
        if (removeListener == null) {
          removeListener = true;
        }
        if (!exports.loaded && type !== 'connect') {
          exports.log("Clay.io has not connected to its backend yet. Use Clay.ready() before this call, or email us if you think the issue is on our end: contact@clay.io");
          return;
        }
        _this = this;
        broadcastType = type;
        if (listener && listener.instanceId) {
          type += '-' + listener.instanceId;
        }
        handler = function(obj) {
          var data;
          exports.log("received: " + type + (obj ? " method: " + obj.method : ''));
          if (obj && obj.data) {
            data = obj.data;
          } else {
            data = null;
          }
          if (obj && obj.method && typeof listener[obj.method] === 'function') {
            if (obj.callbackId) {
              listener[obj.method](data, obj.callbackId);
            } else {
              listener[obj.method](data);
            }
          } else if (typeof listener === 'string') {
            exports[listener][obj.method](data);
          } else if (typeof listener === 'function') {
            listener(data);
          }
          if (removeListener) {
            return _this.socketRemove(type, arguments.callee);
          }
        };
        local.socket.on(type, function(obj) {
          return handler(obj);
        });
        if (type !== broadcastType) {
          return local.socket.on(broadcastType, function(obj) {
            return handler(obj);
          });
        }
      };

      Events.socketRemove = function(type, listener) {
        return local.socket.removeListener(type, listener);
      };

      Events.socketEmit = function(type, method, data, instanceId, callbackId) {
        var obj;
        if (method == null) {
          method = '';
        }
        if (data == null) {
          data = {};
        }
        if (instanceId == null) {
          instanceId = false;
        }
        if (callbackId == null) {
          callbackId = false;
        }
        exports.callsThisMinute++;
        if (exports.callsThisMinute >= local.maxCallsPerMinute) {
          if (exports.callsThisMinute === local.maxCallsPerMinute) {
            exports.UI.createNotification({
              title: "Max Calls Reached",
              html: "This game has reached the maximum number of calls per minute (" + local.maxCallsPerMinute + ")"
            });
          }
          return;
        }
        if (!exports.loaded) {
          return;
        }
        exports.log("sending: " + type + " instance, method: " + method + ": " + instanceId);
        obj = {
          method: method,
          data: data,
          callbackId: callbackId,
          instanceId: instanceId
        };
        return local.socket.emit(type, obj);
      };

      return Events;

    })();
    handler = function(event) {
      var json;
      try {
        json = JSON.parse(event.data);
      } catch (err) {
        json = false;
      }
      if (json && json.name === 'orientationchange') {
        window.innerHeight = parseInt(json.height);
        window.innerWidth = parseInt(json.width);
        window.orientation = parseInt(json.orientation);
        exports.orientation = parseInt(json.orientation);
        return local.Events.triggerEvent('orientationchange');
      } else if (json && json.name === 'orientation') {
        window.orientation = parseInt(json.orientation);
        return exports.orientation = parseInt(json.orientation);
      }
    };
    return local.Events.addEvent('message', handler);
  });

  namespace('Clay', function(exports) {
    var connect, domAndSocketLoaded,
      _this = this;
    exports.loaded = false;
    exports.isReady = false;
    exports.Player = {
      loggedIn: false,
      clearance: false
    };
    connect = function() {
      var tries;
      exports.io || (exports.io = exports.clayio);
      exports.io || (exports.io = window.clayio);
      exports.io || (exports.io = window.io);
      clearTimeout(exports.loadTimeout);
      local.socket = exports.io.connect(exports.SOCKET_ADDRESS, {
        port: exports.SOCKET_PORT,
        secure: exports.PROTOCOL === 'https://'
      });
      tries = 0;
      exports.log('Connecting to socket.io');
      return local.Events.socketListen("connect", function() {
        var json, waitingForDOM;
        if (!exports.loaded) {
          if (local.DOMLoaded) {
            return domAndSocketLoaded();
          } else {
            return waitingForDOM = setInterval(function() {
              exports.log('waiting');
              if (local.DOMLoaded) {
                clearInterval(waitingForDOM);
                return domAndSocketLoaded();
              }
            }, 50);
          }
        } else if (tries < 50) {
          if (exports.User) {
            if (!exports.Player.localStorageChecked && (json = localStorage.getItem('clayLogin'))) {
              json = JSON.parse(json);
              exports.Player.sendLogin(json);
              exports.Player.localStorageChecked = true;
            } else if (exports.windows8) {
              local.callReadies();
            } else {
              local.jsonp('APIGetUserInfo', {}, 'passToNode');
            }
          }
          exports.Game.set({
            key: exports.gameKey,
            options: exports.options
          });
          return tries++;
        }
      });
    };
    domAndSocketLoaded = function() {
      var json;
      exports.loaded = true;
      if (exports.User) {
        exports.Player.socketListen();
        if (json = localStorage.getItem('clayLogin')) {
          json = JSON.parse(json);
          exports.Player.sendLogin(json);
          exports.Player.localStorageChecked = true;
        } else if (exports.windows8) {
          local.callReadies();
        }
      }
      return exports.Game.set({
        key: exports.gameKey,
        options: exports.options
      });
      /*
      		# ** This is called when the user is fully loaded for the dom version **
      		# Call the specified ready funcs
      		local.callReadies()
      */

    };
    local.readiesCalled = false;
    local.callReadies = function() {
      var fn, _i, _len, _ref;
      exports.isReady = true;
      if (local.readiesCalled) {
        return;
      }
      local.readiesCalled = true;
      if (exports.readyFunction) {
        exports.readyFunctions = [exports.readyFunction];
      }
      if (exports.readyFunctions && exports.readyFunctions.length > 0) {
        _ref = exports.readyFunctions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          if (typeof fn === 'function') {
            fn();
          }
        }
      }
      return exports.ready = function(fn) {
        return fn();
      };
    };
    local.loadSocketIO = function() {
      var script, tag;
      if (window.io && window.io.connect) {
        return connect();
      } else {
        if (!exports.options.noExternal) {
          script = document.createElement("script");
          script.type = 'text/javascript';
          window.socketModule = {
            exports: exports
          };
          script.src = exports.BASEURL + '/api/socket.io.js';
          exports.log("Socket.IO Loading... (" + script.src + ")");
          script.onreadystatechange = function() {
            if (this.readyState === 'complete') {
              return connect();
            }
          };
          script.onload = function() {
            return connect();
          };
          tag = document.getElementsByTagName("script")[0];
          return tag.parentNode.insertBefore(script, tag);
        }
      }
    };
    if (local.loadNow) {
      local.loadSocketIO();
    }
    return local.ready(function() {
      var body, json, link, tag;
      if (!local.socket) {
        exports.loadTimeout = setTimeout(function() {
          exports.Game.failedLoadCallback();
          exports.UI.createNotification({
            title: "Error Connecting",
            html: "Email Clay.io support if this message continues to occur contact@clay.io (" + exports.SOCKET_PORT + ")"
          });
          return exports.ready(function() {
            return exports.UI.createNotification({
              title: "Connected",
              html: "Clay.io has connected!"
            });
          });
        }, 12000);
      }
      if (exports.User) {
        exports.Player = exports.player = new exports.User();
      }
      local.container = document.createElement("div");
      local.container.id = "clay";
      local.container.className = "clay";
      if (window.CocoonJS) {
        if (navigator.userAgent.toLowerCase().indexOf("android") === -1) {
          local.container.className = "cocoonjs";
        }
        local.container.addEventListener('click', function(event) {
          if (event.target.tagName === 'A' && event.target.href && event.target.href.substring(0, 4) === 'http') {
            CocoonJS.App.openURL(event.target.href);
            return event.preventDefault();
          }
        });
      }
      body = document.getElementsByTagName("body")[0];
      body.appendChild(local.container);
      body = '';
      if (!local.loadNow) {
        local.loadSocketIO();
      }
      if (exports.User) {
        if (!localStorage.getItem('clayLogin') && !exports.options.noExternal) {
          local.jsonp('APIGetUserInfo', {}, 'passToNode');
        } else {
          local.windowsRequestLogin = true;
        }
      }
      json = {
        name: 'orientation'
      };
      if (parent) {
        parent.postMessage(JSON.stringify(json), '*');
      }
      if (!exports.options || !exports.options.noExternal) {
        link = document.createElement("link");
        link.rel = 'stylesheet';
        link.href = exports.BASEURL + '/api/api.css';
        tag = document.getElementsByTagName("script")[0];
        tag.parentNode.insertBefore(link, tag);
      }
      exports.callsThisMinute = 0;
      local.maxCallsPerMinute = 80;
      return setInterval(function() {
        return exports.callsThisMinute = 0;
      }, 60000);
      /*
      		if window.io && window.io.connect
      			connect()
      		else
      			exports.log 'not connecting'
      			# wait til socket.io is available
      			connectTimes = 0
      			connectInterval = setInterval( (->
      				exports.log 'try'
      				if window.io && window.io.connect
      					connect()
      					clearInterval connectInterval
      				else if connectTimes > 100 # try for 10 seconds
      					clearInterval connectInterval
      					exports.log 'Unable to load socket.io! Make sure you include it in your game files'
      				connectTimes++
      			) , 100 )
      */

    });
  });

  namespace('Clay', function(exports) {
    return exports.UI = (function() {
      /*
      		Contains methods for anything related to User Interface.
      		[Click here](http://clay.io/docs/ui) for our Article Page on UI
      */

      function UI() {}

      UI.modalsOpened = 0;

      UI.notificationsOpened = 0;

      UI.error = function(error, id) {
        var ele, text;
        if (exports.options.hideUI) {
          exports.log("Error: " + error);
          return;
        }
        if (id) {
          ele = document.getElementById(id + '-error');
          if (ele) {
            ele.innerHTML = error;
            ele.style.display = 'block';
          } else {
            ele = document.createElement('div');
            text = document.createTextNode(error);
            ele.id = id + '-error';
            ele.className = 'error';
            ele.appendChild(text);
            document.getElementById(id).insertBefore(ele, document.getElementById(id).firstChild);
          }
          return setTimeout(function() {
            return ele.style.display = 'none';
          }, 3000);
        }
      };

      UI.modalsOpen = function() {
        /*
        			Returns the number of Clay.io modals that are currently open
        			@return (int) number of modals open
        */
        return this.modalsOpened;
      };

      UI.notificationsOpen = function() {
        /*
        			Returns the number of Clay.io notifications that are currently open
        			@return (int) number of notifications open
        */
        return this.notificationsOpened;
      };

      UI.closeModal = function(id, callEvent) {
        var initialModal, modal,
          _this = this;
        if (callEvent == null) {
          callEvent = true;
        }
        /*
        			Closes the most recently opened modal window, or the id passed in options
        			@param [optional] (object) options
        				@option (string) id The DOM id of the modal to close (ex. clay-login-wrapper)
        */

        if (exports.options.hideUI) {
          return;
        }
        if (!id || !(initialModal = document.getElementById(id))) {
          initialModal = document.querySelector('.clay-modal-wrapper, .clay-custom-wrapper');
        }
        if (modal = initialModal) {
          while (modal.parentNode && modal.parentNode !== local.container) {
            modal = modal.parentNode;
          }
          if (callEvent) {
            local.Events.triggerEvent('closemodal', initialModal);
          }
        } else if (local.container.getElementsByTagName("div")[0]) {
          modal = local.container.getElementsByTagName("div")[0];
        } else {
          return;
        }
        try {
          document.getElementById(id).parentNode.parentNode.className += ' clay-fade-out';
        } catch (e) {

        }
        return setTimeout(function() {
          var ele, removed;
          removed = false;
          if (initialModal && initialModal.parentNode && initialModal.className === 'clay-custom-wrapper') {
            initialModal.parentNode.removeChild(initialModal);
          } else if (modal && modal.parentNode) {
            modal.parentNode.removeChild(modal);
            removed = true;
          } else {
            while (ele = document.getElementById(id)) {
              try {
                ele.parentNode.parentNode.parentNode.removeChild(ele.parentNode.parentNode);
                removed = true;
              } catch (e) {

              }
            }
          }
          if (removed) {
            _this.modalsOpened--;
            exports.log("Modal removed (" + _this.modalsOpened + ")");
            if (window.CocoonJS && window.CocoonJS.App && _this.modalsOpened === 0 && _this.notificationsOpened === 0) {
              exports.log('Hiding CocoonJS Webview');
              return CocoonJS.App.hide();
            }
          }
        }, 300);
      };

      UI.getDocumentSize = function() {
        /*
        			@return (object) DOM document 'height' and 'width' in pixels
        */

        var D;
        D = document;
        return Math.max(Math.max(D.body.scrollHeight, D.documentElement.scrollHeight), Math.max(D.body.offsetHeight, D.documentElement.offsetHeight), Math.max(D.body.clientHeight, D.documentElement.clientHeight));
      };

      UI.getWindowSize = function() {
        /*
        			@return (object) Window 'height' and 'width' in pixels
        */

        var myHeight, myWidth;
        myWidth = 0;
        myHeight = 0;
        if (typeof window.innerWidth === "number") {
          myWidth = window.innerWidth;
          myHeight = window.innerHeight;
        } else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
          myWidth = document.documentElement.clientWidth;
          myHeight = document.documentElement.clientHeight;
        } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
          myWidth = document.body.clientWidth;
          myHeight = document.body.clientHeight;
        }
        return {
          height: myHeight,
          width: myWidth
        };
      };

      UI.createModal = function(options, callback) {
        var DOMid, customElements, debugMode, html, icon, id, iframe, modalHTML, subnavHTML, tabs, title,
          _this = this;
        if (options == null) {
          options = {};
        }
        if (callback == null) {
          callback = false;
        }
        /*
        			Creates and displays a modal window
        			@param [required] (object) options
        				@option (string) title Title of modal window
        				@option (string) html HTML for the inner content
        				@option (string) id DOM id to give the wrapper element
        			@example Clay.UI.createModal( { title: 'Title', html: "<div>Here's some HTML</div>" } )
        */

        if (exports.options.hideUI) {
          return;
        }
        title = options.title || '';
        html = options.html || '';
        id = options.id || 'clay-modal-wrapper';
        icon = options.icon || Clay.BASEURL + '/images/logo.svg';
        customElements = options.customElements || [];
        tabs = options.tabs || null;
        subnavHTML = options.subnav || "powered by <a href='" + Clay.BASEURL + "' target='_blank'>clay.io</a>";
        iframe = options.iframe || null;
        debugMode = exports.options && exports.options.debug;
        DOMid = options.DOMid || exports.options.DOMid;
        if (document.getElementById(id)) {
          this.updateModal(options);
          return;
        }
        modalHTML = [];
        if (!DOMid) {
          modalHTML.push("<div class='clay-overlay'>");
          modalHTML.push("	<div class='clay-sticky-cell'>");
          modalHTML.push("		<div class='clay-modal-wrapper' id='" + id + "'>");
          if (tabs) {
            modalHTML.push(typeof tabs === 'string' ? tabs : tabs.join(""));
          }
          modalHTML.push("			<div class='clay-modal clearfix' id='" + id + "-inner'>");
          modalHTML.push("				<div id='" + id + "-header' class='clay-header'>");
          modalHTML.push("					<h2 class='clay-banner'><img src='" + icon + "' /> ");
          modalHTML.push(title);
          if (debugMode) {
            modalHTML.push("			<span class='clay-debug-mode'>Debug Mode</span>");
          }
          modalHTML.push("</h2>");
          modalHTML.push("					<h3 class='clay-powered-by'>" + subnavHTML + "</h3>");
          modalHTML.push("				</div>");
          modalHTML.push("				<a href='#' class='close' id='" + id + "-close'>&times;</a>");
          modalHTML.push("				<div class='clay-content-scroll-hide'>");
        } else {
          modalHTML.push("<div id='" + id + "' class='clay-custom-wrapper'>");
        }
        modalHTML.push("					<div class='clay-content' id='" + id + "-content'>");
        modalHTML.push("						<div class='clay-content-inner' id='" + id + "-content-inner'>");
        modalHTML.push(typeof html === 'string' ? html : html.join(""));
        modalHTML.push("						</div>");
        modalHTML.push("					</div>");
        if (!DOMid) {
          modalHTML.push("				</div>");
          modalHTML.push("			</div>");
          modalHTML.push("			<div class='clay-scroll-lane'><div class='clay-scroll-drag'></div></div>");
          modalHTML.push("		</div>");
          modalHTML.push("	</div>");
          modalHTML.push("</div>");
        } else {
          modalHTML.push("</div>");
        }
        exports.log('Creating the modal');
        this.addToContainer(modalHTML, (function() {
          var closeButton, contentInner, frame, handler, listenCallback, modal;
          if (exports.options.hideUI) {
            return;
          }
          _this.modalsOpened++;
          if (window.CocoonJS && window.CocoonJS.App && _this.modalsOpened >= 1) {
            exports.log("Showing CocoonJS Webview (Modal ID: " + id + ")");
            CocoonJS.App.show(320, 480, 0, 0);
          }
          handler = function(event) {
            exports.UI.closeModal(id);
            return false;
          };
          closeButton = document.getElementById(id + '-close');
          if (closeButton) {
            local.Events.addEvent('touchstart', handler, false, false, closeButton, id);
            local.Events.addEvent('click', handler, false, false, closeButton, id);
          }
          if (iframe) {
            frame = document.createElement('iframe');
            frame.src = iframe.src;
            if (window.CocoonJS) {
              iframe.src += '&cocoonjs';
            }
            frame.frameBorder = '';
            frame.id = iframe.id;
            frame.className = iframe["class"];
            contentInner = document.getElementById(id + "-content-inner");
            contentInner.className += ' loading-iframe';
            contentInner.appendChild(frame);
            listenCallback = function(event) {
              var json;
              if (~exports.BASEURL.indexOf(event.origin)) {
                json = JSON.parse(event.data);
                if (json.makeVisible && contentInner) {
                  return contentInner.className = contentInner.className.replace(' loading-iframe', '');
                }
              }
            };
            local.Events.addEvent('message', listenCallback);
          }
          modal = document.getElementById(id);
          try {
            modal.parentNode.parentNode.className += ' clay-fade-in';
          } catch (e) {

          }
          _this.centerModal(id);
          _this.customElements(customElements);
          if (callback) {
            return callback();
          }
        }), DOMid);
        callback = function(event) {
          event = event || window.event;
          if (event.keyCode === 27) {
            return _this.closeModal(id);
          } else {
            return 'skipRemoval';
          }
        };
        return local.Events.addEvent('keydown', callback, false, true, window, id);
      };

      UI.updateModal = function(options) {
        /*
        			Updates a modal window
        			@param [required] (object) options
        				@option (string) title Title of modal window
        				@option (string) html HTML for the inner content
        				@option (string) id DOM id to give the wrapper element
        			@example Clay.UI.updateModal( { title: 'Title', html: "<div>Here's some HTML</div>" } )
        */

        var customElements, ele, html, id, src, title;
        if (exports.options.hideUI) {
          return;
        }
        title = options.title || '';
        html = options.html || '';
        id = options.id || 'clay-modal-wrapper';
        src = options.src || null;
        customElements = options.customElements || null;
        ele = document.getElementById(id + '-content');
        if (ele) {
          ele.innerHTML = typeof html === 'string' ? html : html.join("");
        }
        exports.log('Updating modal (' + this.modalsOpened + ' open)');
        this.customElements(customElements);
        return this.centerModal(id);
      };

      UI.centerModal = function(id) {
        var drag, dragHeight, header, headerHeight, jumpToSpot, lane, modal, modalContent, modalInner, newHeight, paddingTop, ratio, scrollImg, scrollIndicator, tabHeight, tabs, top, windowHeight;
        if (exports.options.hideUI) {
          return;
        }
        modal = document.getElementById(id) || document.querySelector('.clay-modal-wrapper');
        if (!modal || !document.querySelector('.clay-overlay')) {
          return;
        }
        modalInner = document.getElementById(id + '-inner') || document.querySelector('.clay-modal');
        modalContent = document.getElementById(id + '-content') || document.querySelector('.clay-content');
        modal.style.height = 'auto';
        if (modalContent) {
          modalContent.style.height = 'auto';
        }
        paddingTop = parseInt(modalContent.style.paddingTop) || 78;
        paddingTop -= 10;
        header = document.getElementById(id + '-header') || document.querySelector('.clay-header');
        tabs = document.querySelector('.clay-leaderboard-tabs');
        tabHeight = id === 'clay-leaderboard-wrapper' ? 34 : 0;
        windowHeight = exports.UI.getWindowSize().height;
        document.querySelector('.clay-overlay').style.height = window.innerHeight + 'px';
        lane = modal.querySelector('.clay-scroll-lane');
        lane.style.display = 'none';
        lane.style.top = (header.offsetHeight + 3) + 'px';
        drag = lane.querySelector('.clay-scroll-drag');
        top = (windowHeight - modal.offsetHeight - tabHeight) / 2;
        if (top <= 8) {
          headerHeight = header.offsetHeight;
          newHeight = windowHeight - headerHeight - tabHeight - 22 + paddingTop;
          if (modalContent) {
            modalContent.style.height = newHeight + 'px';
          }
        }
        modalContent.scrollTop = 0;
        ratio = (modalContent.offsetHeight - 5 - paddingTop) / modalContent.scrollHeight;
        if (modalContent.scrollHeight > modalContent.offsetHeight + 2) {
          lane.style.display = 'block';
          dragHeight = Math.round(ratio * modalContent.offsetHeight);
          drag.style.height = dragHeight + 'px';
          if (!(scrollIndicator = document.getElementById(id + '-scroll-indicator'))) {
            scrollIndicator = document.createElement('div');
            scrollIndicator.id = id + '-scroll-indicator';
            scrollIndicator.className = 'clay-scroll-indicator';
            scrollIndicator.onclick = function() {
              return modalContent.scrollTop += 50;
            };
            scrollIndicator.ontouchstart = function() {
              return modalContent.scrollTop += 50;
            };
            scrollImg = document.createElement('img');
            scrollImg.src = exports.BASEURL + '/images/api/down.png';
            scrollIndicator.appendChild(scrollImg);
            modalInner.appendChild(scrollIndicator);
          } else {
            scrollIndicator.style.display = 'block';
          }
          modalContent.className += ' clay-content-scroll';
          if (this.SCROLL_LISTENER) {
            modalContent.removeEventListener(this.SCROLL_LISTENER);
          }
          this.SCROLL_LISTENER = modalContent.addEventListener('scroll', function(e) {
            top = Math.round(modalContent.scrollTop * ratio);
            drag.style.top = top + 'px';
            if ((parseInt(modalContent.scrollTop) + parseInt(modalContent.offsetHeight)) - modalContent.scrollHeight <= 1 && scrollIndicator.style.display !== 'none') {
              return scrollIndicator.style.display = 'none';
            } else if ((parseInt(modalContent.scrollTop) + parseInt(modalContent.offsetHeight)) < modalContent.scrollHeight && scrollIndicator.style.display === 'none') {
              return scrollIndicator.style.display = 'block';
            }
          });
          jumpToSpot = function(e) {
            var h, topY;
            modalContent = modal.querySelector('.clay-content');
            drag = modal.querySelector('.clay-scroll-drag');
            h = drag.offsetHeight;
            topY = Math.round(e.offsetY - h / 2);
            return modalContent.scrollTop = topY;
          };
          if (this.jump1) {
            lane.removeEventListener(this.jump1);
          }
          if (this.jump2) {
            lane.removeEventListener(this.jump2);
          }
          this.jump1 = lane.addEventListener('mousedown', jumpToSpot);
          return this.jump2 = lane.addEventListener('touchstart', jumpToSpot);
        } else {
          modalContent.className += ' clay-content-no-scroll';
          scrollIndicator = document.getElementById(id + '-scroll-indicator');
          if (scrollIndicator) {
            return scrollIndicator.style.display = 'none';
          }
        }
      };

      UI.scroller = null;

      UI.customElements = function(customElements) {
        var ele, index, item, _results;
        _results = [];
        for (index in customElements) {
          item = customElements[index];
          ele = document.getElementById(item.parentElementId);
          if (ele) {
            ele.appendChild(item.element);
          }
          if (item.action && item.action !== 'click') {
            _results.push(local.Events.addEvent(item.action, item.handler, false, false, item.element));
          } else {
            local.Events.addEvent('click', item.handler, false, false, item.element);
            _results.push(local.Events.addEvent('touchstart', item.handler, false, false, item.element));
          }
        }
        return _results;
      };

      UI.notificationOffset = 0;

      UI.notificationId = 0;

      UI.createNotification = function(options) {
        var debugMode, delay, html, icon, id, notificationHTML, title, type,
          _this = this;
        if (options == null) {
          options = {};
        }
        /*
        			Creates and displays a notification message (this is used for things like achievements).
        			@param [required] (object) options
        				@option (string) title Title of notification
        				@option (string) html HTML for the inner content
        				@option (truthy) icon Boolean false if no icon, URL to icon if you want to specify one
        				@option (string) type We use two values, 'notification'|'achievement' -- the style differs a bit between the two. Classes are set with the type (ex. "clay-" + type)
        				@option (string) id DOM id to assign to wrapper (it's assigned as "clay-" + type + "-" + id). Defaults to 'notification'
        				@option (int) delay Notification will be closed after delay ms. Set to 0 to not close at all
        			@example Clay.UI.createNotification( { title: 'Title', html: "<div>Here's some HTML</div>" } )
        */

        if (exports.options.hideUI) {
          return;
        }
        title = options.title || '';
        html = options.html || '';
        icon = options.icon || false;
        type = options.type || 'notification';
        id = options.id || exports.UI.notificationId++;
        delay = options.delay || 3000;
        debugMode = exports.options && exports.options.debug;
        notificationHTML = [];
        notificationHTML.push("<div class='clay-notification clay-" + type + "' id='clay-" + type + "-" + id + "' style='margin-top: " + this.notificationOffset + "px'>");
        notificationHTML.push("	<div class='clay-notification-header clay-" + type + "-header'>");
        notificationHTML.push(title);
        if (debugMode) {
          notificationHTML.push("			<span class='clay-debug-mode'>Debug</span>");
        }
        notificationHTML.push("	</div>");
        notificationHTML.push("	<div class='clay-notification-content clay-" + type + "-content'>");
        if (icon) {
          notificationHTML.push("		<img src='" + icon + "' class='clay-notification-icon clay-" + type + "-icon' />");
        }
        if (icon) {
          notificationHTML.push("			<span class='clay-notification-description clay-" + type + "-description'>");
        }
        notificationHTML.push(html);
        if (icon) {
          notificationHTML.push("			</span>");
        }
        notificationHTML.push("		</div>");
        notificationHTML.push("<a href='#' id='clay-" + type + "-" + id + "-close' class='clay-notification-close clay-" + type + "-close'>&times;</a>");
        notificationHTML.push("</div>");
        this.addToContainer(notificationHTML, function() {
          var ele;
          document.getElementById("clay-" + type + "-" + id + '-close').onclick = function() {
            exports.UI.closeNotification("clay-" + type + "-" + id);
            return false;
          };
          ele = document.getElementById("clay-" + type + "-" + id);
          try {
            ele.className += ' clay-fade-in';
          } catch (e) {

          }
          if (ele) {
            _this.notificationOffset += ele.offsetHeight + 5;
          }
          _this.notificationsOpened++;
          if (window.CocoonJS && window.CocoonJS.App && _this.notificationsOpened >= 1 && _this.modalsOpened === 0) {
            exports.log('Showing CocoonJS Webview');
            return CocoonJS.App.show(300, 120, window.innerWidth / 2 - 300, window.innerWidth - 120);
          }
        });
        if (exports.player.clearance !== 'clay' && type === 'achievement') {
          delay = 5000;
        }
        if (delay > 0) {
          return setTimeout(function() {
            return _this.closeNotification("clay-" + type + "-" + id);
          }, delay);
        }
      };

      UI.closeNotification = function(id) {
        var ele,
          _this = this;
        if (id == null) {
          id = '0';
        }
        /*
        			Closes a notification
        			@param [required] (string) id DOM id assigned to wrapper (it's assigned as "clay-" + type + "-" + id)
        */

        if (exports.options.hideUI) {
          return;
        }
        ele = document.getElementById(id);
        if (ele) {
          this.notificationOffset -= ele.offsetHeight + 5;
        }
        if (ele) {
          this.notificationsOpened--;
        }
        if (window.CocoonJS && window.CocoonJS.App && this.modalsOpened === 0 && this.notificationsOpened === 0) {
          exports.log('Hiding CocoonJS Webview');
          CocoonJS.App.hide();
        }
        try {
          document.getElementById(id).className += ' clay-fade-out';
        } catch (e) {

        }
        return setTimeout(function() {
          return _this.removeElement(id);
        }, 300);
      };

      UI.showPopupNotifier = function(site) {
        return exports.UI.createNotification({
          id: 'popup-' + site,
          delay: '0',
          title: "Popup Blocker",
          html: "We're opening a window to " + site + ". Be sure your popup blocker allows popups from Clay.io"
        });
      };

      UI.hidePopupNotifier = function(site) {
        return exports.UI.closeNotification('clay-notification-popup-' + site);
      };

      UI.addToContainer = function(html, callback, DOMid) {
        var ele, wrapperDiv;
        if (callback == null) {
          callback = false;
        }
        if (DOMid == null) {
          DOMid = false;
        }
        /*
        			Adds an element to the clay container div
        			@param [required] (string) id DOM id assigned to wrapper (it's assigned as "clay-" + type + "-" + id)
        */

        if (exports.options.hideUI) {
          return;
        }
        wrapperDiv = document.createElement('div');
        wrapperDiv.className = 'clay';
        if (typeof html === 'object' && Object.prototype.toString.call(html) !== '[object Array]') {
          wrapperDiv.appendChild(html);
        } else {
          wrapperDiv.innerHTML += typeof html === 'string' ? html : html.join("");
        }
        if (DOMid && (ele = document.getElementById(DOMid))) {
          ele.appendChild(wrapperDiv);
        } else {
          local.container.appendChild(wrapperDiv);
        }
        if (callback) {
          return callback();
        }
      };

      UI.removeElement = function(element) {
        if (exports.options.hideUI) {
          return;
        }
        if (typeof element === 'string') {
          element = document.getElementById(element);
        }
        if (element && element.parentNode) {
          return element.parentNode.removeChild(element);
        }
      };

      /*
      		@setCanvas: (canvas, callback) ->
      			#ctx = canvas.getContext '2d' || canvas.getContext 'experimental-webgl' || canvas.getContext 'webgl'
      			
      			@canvasWidth = canvas.width || parseInt canvas.style.width
      			@canvasHeight = canvas.height || parseInt canvas.style.height
      			@canvas = document.createElement( 'canvas' )
      			@canvas.width = @canvasWidth
      			@canvas.height = @canvasHeight
      			@canvas.style.position = 'absolute'
      			@canvas.style.top = '0'
      			@canvas.style.left = '0'
      			@ctx = @canvas.getContext('2d')
      			canvas.parentNode.appendChild @canvas
      			callback()
      */


      return UI;

    })();
    /*
    	class exports.UI.canvasInput
    		@inputs = [] # static array of all input objects
    		constructor: (options) ->		
    			x = options.x || 0
    			y = options.y || 0
    			@id = options.id || ''
    			@placeholder = options.placeholder || ''
    			@value = @placeholder
    			@width = options.width || 150
    			@height = options.height || 30
    			@fontSize = options.fontSize || 12
    			@padding = options.padding || 5
    			@onClick = options.onClick || ->
    			@center = options.center || false # centers text
    			@wasOver = false # used for cursor on mouseover (resetting to default)
    			
    			@ctx = @canvas.getContext '2d'
    			@canvasWidth = @canvas.width || parseInt @canvas.style.width
    			@canvasHeight = @canvas.height || parseInt @canvas.style.height
    			@xPos = @canvasWidth / 2 - @width / 2
    			@yPos = y - @height / 2
    			if typeof @defaultBackgroundColor == 'undefined'
    				@defaultBackgroundColor = @ctx.createLinearGradient( @xPos, @yPos, @xPos, @yPos + @height ) # top to bottom
    				@defaultBackgroundColor.addColorStop( 0, "#d5d5d5" )
    				@defaultBackgroundColor.addColorStop( 1, "#eee" )
    	
    			@defaultFontColor ||= '#000'
    			@defaultStrokeColor ||= '#444'
    	
    			
    			@inputIndex = exports.UI.canvasInput.inputs.push( @ ) - 1
    		
    			@refresh()
    	
    			@handleClick = handler = (e) =>
    				e ||= window.event
    				@click e
    			local.Events.addEvent 'click', handler, false, false, @canvas
    			
    		destroy: ->
    			local.Events.removeEvent 'click', @handleClick, false, @canvas			
    			
    		click: (e) ->
    			# make sure the click was within the input box coordinates
    			x = e.offsetX || e.clientX
    			y = e.offsetY || e.clientY
    			if @inBox x, y
    				@focus()
    			else
    				@unfocus()			
    			
    		inBox: (x, y) ->
    			return x >= @xPos && x <= @xPos + @width && y >= @yPos && y <= @yPos + @height	
    	
    		focus: ->
    		
    		unfocus: ->
    			
    		refresh: ->
    			@ctx.fillStyle = if @focused then 'black' else @defaultStrokeColor
    			@ctx.fillRect @xPos - 1, @yPos - 1, @width + 2, @height + 2 # this is our border, strokerect produces too thick of a border
    			
    			@ctx.fillStyle = if @focused then '#efefef' else @defaultBackgroundColor
    			@ctx.fillRect @xPos, @yPos, @width, @height
    			@ctx.fillStyle = @defaultFontColor
    			@ctx.font = @fontSize + 'px "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, "Lucida Grande", sans-serif'
    			text = if @type == 'password' && @value != @placeholder then @value.replace( /./g, '\u25CF' ) else @value
    				
    			textWidth = @ctx.measureText( text ).width
    				
    			offset = @padding
    				
    			# make sure the text isn't too wide
    			if ( ratio = ( textWidth / ( @width - @padding - 3 ) ) ) > 1 # the 3 is just an extra buffer
    				text = text.substr -1 * Math.floor( text.length / ratio )
    			else if @center
    				offset = @width / 2 - textWidth / 2
    				
    			@ctx.fillText text, @xPos + offset , @yPos + @height / 2 + @fontSize / 2
    			
    			if @cursorOn
    				@ctx.fillStyle = @defaultFontColor
    				cursorOffset = @ctx.measureText( text.substring( 0, @cursorPos ) ).width
    				if @center
    					cursorOffset += offset - @padding
    				@ctx.fillRect @xPos + @padding + cursorOffset, @yPos + @padding, 1, @height - 2 * @padding
    		
    		
    	class exports.UI.canvasText extends exports.UI.canvasInput
    		constructor: (@canvas, options) ->
    			@type ||= 'text'
    			@cursorPos = 0
    			@handleKey = handler = (e) =>
    				e ||= window.event
    				@keyDown e
    			local.Events.addEvent 'keydown', handler, false, false
    			
    			@handleMouse = handler = (e) =>
    				e ||= window.event
    				@mouseMove e
    			local.Events.addEvent 'mousemove', handler, false, false, @canvas
    			
    			super(options)
    	
    		destroy: ->
    			local.Events.removeEvent 'click', @handleClick, false, @canvas	
    			local.Events.removeEvent 'keydown', @handleKey, false
    	
    		focus: ->
    			return if @focused
    			@focused = true
    			
    			@cursorInterval = setInterval =>
    				@cursorOn = !@cursorOn
    				@refresh()
    			, 500
    			
    			# bring up keyboard
    			isMobile = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/)
    			# If mobile with CocoonJS, show dialog
    			if typeof ext != "undefined" && typeof ext.IDTK_APP != "undefined"
    				ext.IDTK_APP.addEventListener('ontextdialogfinish', (@value) =>
    					# Do something with the text passed back
    					if @value == @placeholder
    						@value = ''
    					@refresh()
    				)
    				ext.IDTK_APP.makeCall(
    					"showTextDialog",
    					'_DIALOG_TITLE_',
    					'_DIALOGM_ESSAGE',
    					'_INITIAL_TEXT_',
    					'text',
    					'_CANCEL_BUTTON_TEXT_',
    					'_OK_BUTTON_TEXT_'
    				)
    			# if there's not an actual keyboard plugged in (mobile devices), AND the DOM isn't available
    			else if isMobile && document && document.createElement && input = document.createElement( 'input' )
    				input.type = 'text'
    				input.style.opacity = 0
    				input.style.position = 'absolute'
    				input.style.top = @yPos + 'px'
    				input.style.left = @xPos + 'px'
    				input.style.width = input.style.height = 0
    				document.body.appendChild input 
    				input.focus()
    			else if isMobile
    				@value = prompt( @placeholder ) || ''
    			
    			if @value == @placeholder
    				@value = ''
    			@refresh()
    		unfocus: ->
    			@focused = false
    			clearInterval @cursorInterval
    			@cursorOn = false
    			if @value == '' # reset placeholder if still empty
    				@value = @placeholder
    			@refresh()
    				
    		mouseMove: (e) ->
    			x = e.offsetX || e.clientX
    			y = e.offsetY || e.clientY
    			if @inBox( x, y ) && @canvas.style
    				@canvas.style.cursor = 'text'
    				@wasOver = true
    			else if @wasOver && @canvas.style
    				@canvas.style.cursor = 'default'
    				@wasOver = false
    			
    		keyDown: (e) ->
    			if @focused
    				e.preventDefault()
    				cursorVal = true
    				
    				if e.which == 8 # backspace
    					if @cursorPos > 0
    						@value = @value.substr( 0, @cursorPos - 1 ) + @value.substr( @cursorPos, @value.length )
    						@cursorPos--
    				if e.which == 46 # delete key
    					if @cursorPos < @value.length
    						@value = @value.substr( 0, @cursorPos ) + @value.substr( @cursorPos + 1, @value.length )
    				else if e.which == 37 # left arrow
    					@cursorPos--		
    				else if e.which == 39 # right arrow
    					@cursorPos++				
    				else if e.which == 13 # enter key
    					# find closest button and execute it
    					for input in exports.UI.canvasInput.inputs
    						if input.type == 'submit'
    							cursorVal = false # make sure we don't reinstate the cursor
    							@unfocus()
    							input.focus()
    							break
    				else if e.which == 9 # tab
    					cursorVal = false # make sure we don't reinstate the cursor
    					@unfocus()
    					if obj = exports.UI.canvasInput.inputs[@inputIndex + 1]
    						setTimeout (-> obj.focus()), 1 # timeout so it doesn't skip completely past it
    				else if key = @mapKeyPressToActualCharacter e.shiftKey, e.which 
    					@value = @value.substr( 0, @cursorPos ) + key + @value.substr( @cursorPos, @value.length )
    					@cursorPos++ # move the cursor to the right
    				
    				@cursorOn = cursorVal
    				@refresh()
    		# credit to http://stackoverflow.com/a/4786582
    		mapKeyPressToActualCharacter: (isShiftKey, characterCode) ->
    			return false	if characterCode is 27 or characterCode is 8 or characterCode is 9 or characterCode is 20 or characterCode is 16 or characterCode is 17 or characterCode is 91 or characterCode is 13 or characterCode is 92 or characterCode is 18
    			return false	if typeof isShiftKey isnt "boolean" or typeof characterCode isnt "number"
    			characterMap = []
    			characterMap[192] = "~"
    			characterMap[49] = "!"
    			characterMap[50] = "@"
    			characterMap[51] = "#"
    			characterMap[52] = "$"
    			characterMap[53] = "%"
    			characterMap[54] = "^"
    			characterMap[55] = "&"
    			characterMap[56] = "*"
    			characterMap[57] = "("
    			characterMap[48] = ")"
    			characterMap[109] = "_"
    			characterMap[107] = "+"
    			characterMap[219] = "{"
    			characterMap[221] = "}"
    			characterMap[220] = "|"
    			characterMap[59] = ":"
    			characterMap[222] = "\""
    			characterMap[188] = "<"
    			characterMap[190] = ">"
    			characterMap[187] = "+"
    			characterMap[191] = "?"
    			characterMap[32] = " "
    			character = ""
    			if isShiftKey
    				if characterCode >= 65 and characterCode <= 90
    					character = String.fromCharCode(characterCode)
    				else
    					character = characterMap[characterCode]
    			else
    				if characterCode >= 65 and characterCode <= 90
    					character = String.fromCharCode(characterCode).toLowerCase()
    				else
    					if characterCode == 188 # weird cases (onkeydown produces different key than onkeypress)
    						character = ','
    					else if characterCode == 190
    						character = '.'
    					else
    						character = String.fromCharCode(characterCode)
    			return character
    	
    	class exports.UI.canvasPassword extends exports.UI.canvasText
    		constructor: (@canvas, options) ->
    			@type = 'password'
    			super( @canvas, options )
    		
    	class exports.UI.canvasSubmit extends exports.UI.canvasInput
    		constructor: (@canvas, options) ->
    			@type = 'submit'
    			options.center ||= true # centers text
    			@defaultBackgroundColor = '#666'
    			@defaultFontColor = '#fff'
    			@defaultStrokeColor = '#000'
    			super(options)
    		focus: ->
    			@onClick()
    */

  });

  namespace('Clay', function(exports) {
    return exports.Tools = (function() {

      function Tools() {}

      Tools.broadcast = function(message) {
        return local.Events.socketEmit('broadcast', 'send', message);
      };

      return Tools;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Stats = (function() {

      function Stats() {}

      /*
      		Contains methods for anything related to logging statistics.
      		[Click here](http://clay.io/docs/analytics) for our Article Page on Analytics
      */


      Stats.log = function(options) {
        /*
        			Logs a custom statistic. The graph can be viewed in the developer area for your game, under 'stats'
        			@param [required] (object) options
        				@option (string) name The name/key to associate this stat with
        				@option (int) quantity  Defaults to 1 -- a value to associate with the stat
        			@example Clay.Stats.logStat( 'talkedToNPC', 1 );
        */

        var quantity, type;
        type = options.name;
        quantity = options.quantity || 1;
        return local.Events.socketEmit('stats', 'logFromAPI', {
          type: type,
          quantity: quantity
        }, 1);
      };

      Stats.logStat = function(options) {
        return this.log(options);
      };

      Stats.level = function(options) {
        /*
        			For statistics associated with game levels. You can start and end levels to gather
        			statistics on dropout rate, time to complete, etc...
        			@param [required] (object) options
        				@option (string) action One of: 'start', 'pass', 'fail'
        				@option (string) level A unique identifier for the current level
        			@example Clay.Stats.level( { action: 'start', level: 1 } );
        */
        return local.Events.socketEmit('stats', 'level', options, 1);
      };

      return Stats;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Payment = (function() {
      /*
      		Contains methods for anything related to Clay.io in-game payments. Must be instantiated with "new"
      		[Click here](http://clay.io/docs/payments) for our Article Page on Payments
      */

      function Payment() {
        this.items = {};
        this.itemCallback = [];
        this.instanceId = Math.random();
        local.Events.socketListen("payment", this, null, false);
      }

      Payment.prototype.addItem = function(options, callback) {
        var callbackId, id, type;
        if (callback == null) {
          callback = false;
        }
        /*
        			Adds an item to the user's cart
        			@param [required] (object) options
        				@option (int) id Item ID. Given in developer dashboard for game after creating the item
        			@param [optional] (function) callback called when item has been added to cart
        				@arg (object) response
        					@property (bool) success true if item was successfuly added, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        			@example (new Clay.Payments()).addItem( { id: 1 }, function( response )
        			{
        				console.log( response );
        			}
        */

        if (typeof options !== 'object') {
          options = {
            id: options,
            type: 'item'
          };
          exports.log('This form of passing item ID is deprecated');
        }
        id = options.id;
        type = options.type;
        type || (type = 'item');
        if (this.items[id]) {
          this.items[id].quantity++;
          if (callback) {
            return callback(this.items[id].data);
          }
        } else {
          callbackId = local.Callbacks.add(callback);
          return local.Events.socketEmit('payment', 'addItem', options, this.instanceId, callbackId);
        }
      };

      Payment.prototype.addItemStore = function(obj, callbackId) {
        if (callbackId == null) {
          callbackId = false;
        }
        if (obj.success) {
          this.items[obj.id] = {
            type: obj.type || 'item',
            quantity: 1,
            data: obj
          };
        }
        if (callbackId) {
          return local.Callbacks.execute(callbackId, [obj]);
        }
      };

      Payment.prototype.getItemIds = function() {
        /*
        			Fetches the ids of items the user playing your game 'owns'
        			@return (array) items Array of item ids. Ex. [1, 5, 6, 7]
        */

        var i, id, ids, item, _i, _ref, _ref1;
        ids = [];
        _ref = this.items;
        for (id in _ref) {
          item = _ref[id];
          for (i = _i = 1, _ref1 = item.quantity; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
            ids.push(item.type + '_' + id);
          }
        }
        return ids;
      };

      Payment.prototype.removeItem = function(options) {
        /*
        			Removes an item from the users cart. If the quantity is greater than one, it just reduces the quantity by 1
        			@param [required] (object) options
        				@option (int) id Item ID. Given in developer dashboard for game after creating the item
        */
        if (typeof options !== 'object') {
          options = {
            id: options
          };
          exports.log('This form of passing item ID is deprecated');
        }
        if (this.items[options.id] && this.items[options.id].quantity > 1) {
          this.items[options.id].quantity--;
          return document.getElementById('clay-item-quantity-' + options.id).innerHTML = this.items[options.id].quantity;
        } else {
          delete this.items[options.id];
          return exports.UI.removeElement(document.getElementById('clay-item-' + options.id));
        }
      };

      Payment.prototype.generateRemoveLink = function(id) {
        var link;
        link = document.createElement('a');
        link.href = '#';
        link.appendChild(document.createTextNode('x'));
        return link;
      };

      Payment.prototype.checkout = function(options, callback) {
        var arrayOfCustomElements, id, item, modalOptions, onSubmit, paymentHTML, submit, _fn, _ref, _ref1, _this;
        if (options == null) {
          options = {};
        }
        /*
        			Initiates the checkout sequence within Clay.io where the user is asked to confirm the purchase, then directed through the payment processors
        			@param [optional] (object) options
        				@option (string) id Specify if you do not want to use the standard Clay.io UI. Pass the DOM element ID you want the payment box to go in
        			@param [optional] (function) callback Called when either purchase has successfully gone through, or if there was an error/canceled process
        				@arg (object) response
        					@property (bool) success True if the user went through the whole process without generating an error
        					@property (truthy) error Boolean false if no error, String error message if error
        					@property (string) status Info about the payments current status (ex. pending) - this still needs to be normalized on our end. Give us a nudge if we haven't done it yet
        					@property (bool) completed Boolean if the payment was approved right away or not
        					@property (array) itemIds Array of Integers: The items they ended up purchasing - this could be different than the items you pass since they can optionally remove items
        */

        _this = this;
        if (typeof options !== 'object') {
          callback = options;
        }
        arrayOfCustomElements = [];
        paymentHTML = [];
        paymentHTML.push("<table>");
        paymentHTML.push("	<thead>");
        paymentHTML.push("		<tr>");
        paymentHTML.push("			<th>Item Name</th>");
        paymentHTML.push("			<th>Quantity</th>");
        paymentHTML.push("			<th>Item Price</th>");
        paymentHTML.push("			<th>Remove</th>");
        paymentHTML.push("		</tr>");
        paymentHTML.push("	</thead>");
        paymentHTML.push("	<tbody>");
        _ref = this.items;
        for (id in _ref) {
          item = _ref[id];
          paymentHTML.push("	<tr id='clay-item-" + id + "'>");
          paymentHTML.push("		<td>" + item.data.name + "</td>");
          paymentHTML.push("		<td id='clay-item-quantity-" + id + "'>" + item.quantity + "</td>");
          paymentHTML.push("		<td id='clay-item-quantity-" + id + "'>$" + item.data.price + "</td>");
          paymentHTML.push("		<td id='clay-remove-link-wrapper-" + id + "'></td>");
          paymentHTML.push("	</tr>");
        }
        paymentHTML.push("	</tbody>");
        paymentHTML.push("</table>");
        paymentHTML.push("<span id='clay-submit-button'></span>");
        submit = document.createElement('input');
        submit.type = 'submit';
        submit.value = 'Checkout';
        onSubmit = function() {
          return _this.pay(callback);
        };
        arrayOfCustomElements.push({
          parentElementId: 'clay-submit-button',
          element: submit,
          handler: onSubmit
        });
        _ref1 = this.items;
        _fn = function() {
          var link, localId, onClick;
          localId = id;
          link = _this.generateRemoveLink(localId);
          onClick = function() {
            _this.removeItem(localId);
            return false;
          };
          return arrayOfCustomElements.push( { parentElementId: 'clay-remove-link-wrapper-' + localId, element: link, handler: onClick } );
        };
        for (id in _ref1) {
          item = _ref1[id];
          _fn();
        }
        modalOptions = {
          title: 'Purchase',
          html: paymentHTML,
          id: 'clay-payment-wrapper',
          customElements: arrayOfCustomElements,
          DOMid: options.id
        };
        return exports.UI.createModal(modalOptions);
      };

      Payment.prototype.pay = function(callback) {
        var _this;
        _this = this;
        return exports.player.requireLogin(function() {
          var debug, listenCallback, options, paymentHTML, wrapper;
          wrapper = document.getElementById('clay-payment-wrapper');
          if (wrapper) {
            wrapper.style.maxWidth = '339px';
          }
          paymentHTML = [];
          debug = exports.options && exports.options.debug ? '&debug' : '';
          paymentHTML.push("<iframe src='" + Clay.BASEURL + "/api/payment/?items=" + _this.getItemIds().join(",") + '&game_id=' + Clay.gameID + debug + "' id='clay-payment-iframe' frameBorder='0'></iframe>");
          options = {
            title: 'Purchase',
            html: paymentHTML,
            id: 'clay-payment-wrapper',
            src: Clay.BASEURL + '/images/api/clay_shopping_cart.png'
          };
          exports.UI.updateModal(options);
          listenCallback = function(event) {
            var json;
            if (~exports.BASEURL.indexOf(event.origin)) {
              json = JSON.parse(event.data);
              if (json.height) {
                document.getElementById('clay-payment-iframe').style.height = json.height + 'px';
                document.getElementById('clay-payment-iframe').style.width = json.width + 'px';
                if (wrapper) {
                  wrapper.style.maxWidth = (parseInt(json.width) + 30) + 'px';
                }
                return exports.UI.centerModal('clay-payment-wrapper');
              } else if (json.popup) {
                return exports.UI.showPopupNotifier(json.popup);
              } else if (json.popupClose) {
                return exports.UI.hidePopupNotifier(json.popupClose);
              } else if (json.backToCart) {
                return _this.checkout();
              } else {
                _this.paymentCallback(json, callback);
                return local.Events.removeEvent('message', arguments.callee);
              }
            }
          };
          return local.Events.addEvent('message', listenCallback);
        }, true);
      };

      Payment.prototype.paymentCallback = function(json, callback) {
        exports.UI.closeModal('clay-payment-wrapper');
        if (callback) {
          callback(json);
        }
        return local.Events.socketEmit('payment', 'complete', json);
      };

      return Payment;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Broadcast = (function() {

      function Broadcast() {
        var _this;
        _this = this;
        local.Events.socketListen("broadcast", this);
      }

      Broadcast.prototype.show = function(message) {
        var broadcast;
        broadcast = [];
        broadcast.push("<div class='clay-achievement'>");
        broadcast.push("<a href='javascript: void( 0 );' onclick='Clay.closeModal();' class='close'>&times;</a>");
        broadcast.push(message);
        broadcast.push("</div>");
        return exports.modal.innerHTML = broadcast.join("");
      };

      return Broadcast;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Ratings = (function() {

      function Ratings(options) {
        var ele, listenCallback, modalOptions, rateHTML;
        if (options == null) {
          options = {};
        }
        /*
        			Call to open the ratings modal. The ratings modal lets users rate and comment on your game.
        			@param [required] (object) options
        				@option (int) id DOM element id. If passed, the rating iframe will be put in that element. If not passed, it will be opened in the modal window.
        			@example new Clay.Ratings()
        */

        rateHTML = [];
        rateHTML.push("<iframe src='" + exports.BASEURL + "/api/rate/?id=" + exports.gameID + "' id='clay-rate-iframe' frameBorder='0'></iframe>");
        modalOptions = {
          title: 'Rate this Game',
          html: rateHTML,
          id: 'clay-rate-wrapper'
        };
        if (options.id && (ele = document.getElementById(options.id))) {
          ele.innerHTML = html.join('');
        } else {
          exports.UI.createModal(modalOptions);
        }
        listenCallback = function(event) {
          var json;
          if (~exports.BASEURL.indexOf(event.origin)) {
            json = JSON.parse(event.data);
            if (json.height) {
              ele = document.getElementById('clay-rate-iframe');
              ele.height = json.height;
              ele.style.height = json.height + 'px';
              return exports.UI.centerModal('clay-rate-wrapper');
            }
          }
        };
        local.Events.addEvent('message', listenCallback);
      }

      return Ratings;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Suggestions = (function() {

      function Suggestions(options) {
        var ele, html, listenCallback, modalOptions;
        if (options == null) {
          options = {};
        }
        /*
        			Call to open the suggestions modal. The game suggestions modal displays 3 recommended games. Each time one is clicked you earn credits that will get you clicks to your game from others. More info [here](http://clay.io/docs/suggestions)
        			@param [required] (object) options
        				@option (int) id DOM element id. If passed, the rating iframe will be put in that element. If not passed, it will be opened in the modal window.
        			@example new Clay.Suggestions()
        */

        html = [];
        html.push("<iframe src='" + Clay.BASEURL + "/api/suggestions/?id=" + exports.gameID + "' id='clay-suggestions-iframe' frameBorder='0'></iframe>");
        modalOptions = {
          title: 'Game Suggestions',
          html: html,
          id: 'clay-suggestions-wrapper'
        };
        if (options.id && (ele = document.getElementById(options.id))) {
          ele.innerHTML = html.join('');
        } else {
          exports.UI.createModal(modalOptions);
        }
        listenCallback = function(event) {
          var json;
          if (~exports.BASEURL.indexOf(event.origin)) {
            json = JSON.parse(event.data);
            if (json.height) {
              document.getElementById('clay-suggestions-iframe').height = json.height;
              return exports.UI.centerModal('clay-suggestions-wrapper');
            }
          }
        };
        local.Events.addEvent('message', listenCallback);
      }

      return Suggestions;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Game = (function() {

      function Game() {}

      Game.listening = false;

      Game.data = {};

      Game.set = function(options, setCallback) {
        if (options == null) {
          options = {};
        }
        this.setCallback = setCallback != null ? setCallback : false;
        if (!this.listening) {
          local.Events.socketListen("game", 'Game');
          this.listening = true;
        }
        options.referrer = window.location !== window.parent.location ? document.referrer : document.location.href;
        if (!options.referrer || window.CocoonJS) {
          if (navigator.userAgent.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)) {
            options.referrer = 'ios';
          }
          if (navigator.userAgent.match(/(Android)/i)) {
            options.referrer = 'android';
          }
        }
        return local.Events.socketEmit('game', 'set', options);
      };

      Game.getData = function() {
        /*
        			@return an object of data pertaining to your game
        				{ id: (int) game ID, name: (string) name of game }
        */

      };

      Game.store = function(obj) {
        var style, tag;
        this.data = obj;
        exports.gameID = obj.id;
        if (obj.css && (!exports.options || !exports.options.noExternal)) {
          style = document.createElement("style");
          style.appendChild(document.createTextNode(obj.css));
          tag = document.getElementsByTagName("script")[0];
          tag.parentNode.insertBefore(style, tag);
        }
        if (exports.options.noExternal && obj.showLogin && !exports.Player.loggedIn && local.windowsRequestLogin) {
          exports.Player.login();
        }
        if (this.setCallback) {
          return this.setCallback();
        }
      };

      Game.failedLoadCallback = function() {
        if (exports.options && exports.options.fail) {
          return exports.options.fail();
        }
      };

      Game.error = function(error) {
        return exports.UI.error(error);
      };

      return Game;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Rooms = (function() {
      /*
      		Contains methods for anything related to making posts to Clay.io multiplayer rooms. Must be instantiated with "new"
      		Multiplayer rooms allow you to divide players up into rooms (rooms they create and can join or invite others to join)
      		[Click here](http://clay.io/docs/rooms) for our Article Page on Rooms
      */

      function Rooms(fullCallback) {
        this.fullCallback = fullCallback;
        /*
        			Instantiates the Rooms object
        			@param [optional] (function) fullCallback Called when a room is full (for any user)
        				@arg (object) response
        					@property (bool) success true if the room was successfully created, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        					@property (int) id A unique ID of the room that was created, starting from 0
        					@property (int) count The number of people in the room
        					@property (int) max The maximum number of players allowed in a room (specified in Developer Game Settings)
        					@property (object) instance A reference to the Clay.Rooms instance (so you can use response.instance.leaveRoom() if you'd like)
        					@property (string) name The name created by a user for the room
        */

        this.instanceId = Math.random();
        this.rooms = {};
        this.room = false;
        local.Events.socketListen("rooms", this, null, false);
      }

      Rooms.prototype.setFullCallback = function(fullCallback) {
        this.fullCallback = fullCallback;
      };

      Rooms.prototype.show = function(callback) {
        /*
        			Shows the rooms list modal
        			@param [optional] (function) callback Called when the rooms modal is done loading
        				@arg rooms (array) Array of all non-full rooms. Each array element contains objects with the following properties
        					@property (int) count Number of players currently in the room
        					@property (int) id Unique ID of the room
        					@property (int) max The maximun number of users allowed in the room
        					@property (array) members Array of objects with the property *name* being their name
        					@property (string) name The name of the room
        */

        var _this = this;
        return exports.Player.requireLogin(function() {
          var callbackId;
          callbackId = local.Callbacks.add(callback);
          return local.Events.socketEmit('rooms', 'show', {}, _this.instanceId, callbackId);
        });
      };

      Rooms.prototype.showCallback = function(obj, callbackId) {
        var arrayOfCustomElements, header, html, id, onSubmit, options, room, submit, _i, _len, _ref, _ref1, _ref2, _this;
        _this = this;
        this.rooms = obj.rooms;
        html = [];
        html.push("<table>");
        html.push("<thead>");
        _ref = obj.header;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          header = _ref[_i];
          html.push("<th>" + header + "</th>");
        }
        html.push("<tbody id='clay-rooms'>");
        _ref1 = obj.rooms;
        for (id in _ref1) {
          room = _ref1[id];
          if (room) {
            html.push("<tr id='clay-room-" + id + "'>");
            html.push(this.getRoomTd(room, false, false, true));
            html.push("</tr>");
          }
        }
        html.push("</tbody>");
        html.push("</table>");
        html.push("<span id='clay-room-add'>");
        html.push("	<input type='text' id='clay-room-name' placeholder='New Room Name' /> <span id='clay-create-room-button'></span>");
        html.push("</span>");
        arrayOfCustomElements = [];
        _ref2 = obj.rooms;
        for (id in _ref2) {
          room = _ref2[id];
          if (room && room.count < room.max) {
            (function() {
              var join, localId, onClick, text;
              localId = id;
              join = document.createElement('a');
              join.href = '#';
              text = document.createTextNode('Join Room');
              join.appendChild(text);
              onClick = function() {
                _this.joinRoom(localId);
                return false;
              };
              return arrayOfCustomElements.push( { parentElementId: 'clay-join-' + localId + '-link', element: join, handler: onClick } );;
            })();
          }
        }
        submit = document.createElement('input');
        submit.type = 'submit';
        submit.value = 'Create Room';
        onSubmit = function() {
          return _this.createRoom();
        };
        arrayOfCustomElements.push({
          parentElementId: 'clay-create-room-button',
          element: submit,
          handler: onSubmit
        });
        options = {
          title: 'Rooms',
          html: html,
          id: 'clay-rooms-wrapper',
          customElements: arrayOfCustomElements
        };
        exports.UI.createModal(options);
        return local.Callbacks.execute(callbackId, [obj.rooms]);
      };

      Rooms.prototype.getRooms = function() {
        /*
        			Fetches an array of all rooms currently created
        			@return (array) Array of all non-full rooms. Each array element contains objects with the following properties
        				@property (int) count Number of players currently in the room
        				@property (int) id Unique ID of the room
        				@property (int) max The maximun number of users allowed in the room
        				@property (array) members Array of objects with the property *name* being their name
        				@property (string) name The name of the room
        */
        return this.rooms;
      };

      Rooms.prototype.createRoom = function(options, callback) {
        var callbackId, ele;
        if (options == null) {
          options = {};
        }
        if (callback == null) {
          callback = false;
        }
        /*
        			Allows you to manually create the room (the modal flow provides all of this for a user, so this is just if you want to manually create one)
        			@param [optional] (object) options
        				@option (string) name The name of the room. If left blank, it grabs the value from the rooms text field
        			@param [optional] (function) callback Called when room is created
        				@arg room (array) An object with the following properties
        					@property (int) count Number of players currently in the room
        					@property (int) id Unique ID of the room
        					@property (int) max The maximun number of users allowed in the room
        					@property (array) members Array of objects with the property *name* being their name
        					@property (string) name The name of the room
        */

        if (callback) {
          callbackId = local.Callbacks.add(callback);
        }
        ele = document.getElementById('clay-room-name');
        if (ele) {
          options.name || (options.name = ele.value);
        }
        return local.Events.socketEmit('rooms', 'createRoom', {
          name: options.name
        }, this.instanceId, callbackId);
      };

      Rooms.prototype.createRoomCallback = function(obj, callbackId) {
        var roomAdd, row, table;
        if (obj.success) {
          table = document.getElementById('clay-rooms');
          row = this.getRoomTd(obj, true);
          if (table && row) {
            table.appendChild(row);
          }
          roomAdd = document.getElementById('clay-room-add');
          if (roomAdd) {
            roomAdd.innerHTML = "Room created, waiting for more players...";
          }
          this.room = obj.id;
          this.rooms[obj.id] = {
            name: obj.name,
            count: obj.count
          };
          if (this.rooms[obj.id].count >= obj.max) {
            this.roomFull(obj);
          }
        }
        if (callbackId) {
          return local.Callbacks.execute(callbackId, [this.rooms[obj.id]]);
        }
      };

      Rooms.prototype.getRoomTd = function(obj, inRoom, tr, returnHTML) {
        var html, span, td, text;
        if (inRoom == null) {
          inRoom = false;
        }
        if (tr == null) {
          tr = false;
        }
        if (returnHTML == null) {
          returnHTML = false;
        }
        if (returnHTML) {
          html = [];
          html.push("<td>" + obj.name + "</td>");
          html.push("<td>" + obj.count + "</td>");
          html.push("<td><span id='clay-join-" + obj.id + "-link'>" + (inRoom ? 'In Room' : obj.count >= obj.max ? 'Room Full' : '') + "</span></td>");
          return html.join("");
        } else {
          if (!tr) {
            tr = document.createElement('tr');
            tr.id = 'clay-room-' + obj.id;
          }
          td = document.createElement('td');
          text = document.createTextNode(obj.name);
          td.appendChild(text);
          tr.appendChild(td);
          td = document.createElement('td');
          text = document.createTextNode(obj.count);
          td.appendChild(text);
          tr.appendChild(td);
          td = document.createElement('td');
          span = document.createElement('span');
          span.id = "clay-join-" + obj.id + "-link";
          text = document.createTextNode(inRoom ? 'In Room' : obj.count >= obj.max ? 'Room Full' : '');
          span.appendChild(text);
          td.appendChild(span);
          tr.appendChild(td);
          return tr;
        }
      };

      Rooms.prototype.joinRoom = function(options, callback) {
        var callbackId;
        if (callback == null) {
          callback = false;
        }
        /*
        			Allows you to manually have a user join a room
        			@param [optional] (object) options
        				@option (int) id The ID of the room for them to join
        			@param [optional] (function) callback Called when room is joined
        				@arg room (array) An object with the following properties
        					@property (int) count Number of players currently in the room
        					@property (int) id Unique ID of the room
        					@property (int) max The maximun number of users allowed in the room
        					@property (array) members Array of objects with the property *name* being their name
        					@property (string) name The name of the room
        */

        if (typeof options !== 'object') {
          options = {
            id: options
          };
          exports.log('This form of passing item ID is deprecated');
        }
        if (callback) {
          callbackId = local.Callbacks.add(callback);
        }
        return local.Events.socketEmit('rooms', 'joinRoom', options, this.instanceId, callbackId);
      };

      Rooms.prototype.joinRoomCallback = function(obj, callbackId) {
        if (obj.success) {
          this.room = obj.id;
          this.rooms[obj.id].count++;
          this.refreshTd(obj.id, true);
          if (this.rooms[obj.id].count >= obj.max) {
            this.roomFull(obj);
          }
        } else {
          exports.UI.error(obj.error, 'clay-rooms-wrapper-content');
        }
        if (callbackId) {
          return local.Callbacks.execute(callbackId, [this.rooms[obj.id]]);
        }
      };

      Rooms.prototype.leaveRoom = function(callback) {
        var callbackId;
        if (callback == null) {
          callback = false;
        }
        /*
        			Allows you to manually remove a user from a room
        			@param [optional] (object) options
        				@option (int) id The ID of the room for them to join
        			@param [optional] (function) callback Called when room is joined
        				@arg (object) response
        					@property (bool) success true if the user was successfully removed from the room, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        */

        if (callback) {
          callbackId = local.Callbacks.add(callback);
        }
        return local.Events.socketEmit('rooms', 'leaveRoom', {}, this.instanceId, callbackId);
      };

      Rooms.prototype.leaveRoomCallback = function(obj, callbackId) {
        if (callbackId) {
          return local.Callbacks.execute(callbackId);
        }
      };

      Rooms.prototype.refresh = function(obj) {
        this.rooms[obj.id] = {
          name: obj.name,
          count: obj.count
        };
        this.refreshTd(obj.id);
        if (obj.count >= obj.max) {
          return this.roomFull(obj);
        }
      };

      Rooms.prototype.roomFull = function(obj) {
        if (this.room === obj.id) {
          obj.instance = this;
          if (this.fullCallback) {
            this.fullCallback(obj);
          }
          exports.UI.closeModal('clay-rooms-wrapper');
        }
        exports.UI.removeElement(document.getElementById('clay-room-' + obj.id));
        return delete this.rooms[obj.id];
      };

      Rooms.prototype.refreshTd = function(id, inRoom) {
        var arrayOfCustomElements, ele, join, onClick, room, roomsTable, text,
          _this = this;
        if (inRoom == null) {
          inRoom = false;
        }
        room = this.rooms[id];
        room.id = id;
        ele = document.getElementById('clay-room-' + id);
        if (ele && room.count > 0) {
          if (ele) {
            this.getRoomTd(room, inRoom, ele);
          }
        } else if (ele) {
          exports.UI.removeElement(ele);
        } else {
          roomsTable = document.getElementById('clay-rooms');
          if (roomsTable) {
            roomsTable.appendChild(this.getRoomTd(room, inRoom));
          }
        }
        if (!inRoom) {
          join = document.createElement('a');
          join.href = '#';
          text = document.createTextNode('Join Room');
          join.appendChild(text);
          onClick = function() {
            _this.joinRoom(id);
            return false;
          };
          arrayOfCustomElements = [];
          ele = document.getElementById('clay-join-' + id + '-link');
          if (ele) {
            ele.innerHTML = '';
          }
          arrayOfCustomElements.push({
            parentElementId: 'clay-join-' + id + '-link',
            element: join,
            handler: onClick
          });
          return exports.UI.customElements(arrayOfCustomElements);
        }
      };

      return Rooms;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Screenshot = (function() {
      /*
      		Contains methods for anything related to screenshots. Must be instantiated with "new"
      		Screenshots are stored on the Clay.io server and associated with the user's account
      		[Click here](http://clay.io/docs/screenshots) for our Article Page on Screenshots
      */

      function Screenshot(options, callback) {
        if (callback == null) {
          callback = false;
        }
        /*
        			Instantiates the Screenshot object and starts the flow unless you specify otherwise
        			@param [optional] (object) options
        				@option (boolean) prompt Set to false if you don't want the Screenshot flow to start when instantiating (ie you want to do something with the screenshot in the background)
        			@example new Clay.Screenshot();
        */

        if (options) {
          this.id = options.id || false;
        } else {
          this.id = false;
        }
        if (typeof options === 'undefined' || typeof options.prompt === 'undefined' || options.prompt) {
          this.prompt(callback);
        }
        this.instanceId = Math.random();
        local.Events.socketListen('screenshot', this);
      }

      Screenshot.prototype.prompt = function(callback) {
        /*
        			Manually call the prompt modal to show (prompts a user to save screenshot to Clay.io)
        */

        var callbackFn, canvas, customElements, modalHTML, onClick, options, save,
          _this = this;
        modalHTML = [];
        customElements = [];
        if (this.id) {
          canvas = document.getElementById(this.id);
        } else {
          canvas = document.getElementsByTagName('canvas')[0];
        }
        if (canvas && !this.data) {
          this.data = canvas.toDataURL('image/png');
        }
        modalHTML.push("<img class='clay-screenshot' src='" + this.data + "' height='200' />");
        modalHTML.push("<div id='clay-screenshot-save-" + this.instanceId + "'></div>");
        callbackFn = function(response) {
          if (callback) {
            callback(response);
          }
          return exports.UI.closeModal('clay-screenshot-wrapper');
        };
        onClick = function() {
          return _this.save(callbackFn);
        };
        save = document.createElement('input');
        save.type = 'submit';
        save.value = 'save';
        customElements.push({
          parentElementId: "clay-screenshot-save-" + this.instanceId,
          element: save,
          handler: onClick
        });
        options = {
          title: 'Screenshot',
          html: modalHTML,
          id: 'clay-screenshot-wrapper',
          customElements: customElements
        };
        return exports.UI.createModal(options);
      };

      Screenshot.prototype.save = function(callback) {
        /*
        			Manually saves a screenshot to the Clay.io server (and is associated with the user's account)
        			@param [optional] (object) options
        				@option (string) id By default, we select the first canvas on the page to take a screenshot of -- you can specify a different canvas by passing the DOM id
        				@option (boolean) prompt Set to false if you don't want the Screenshot flow to start when instantiating (ie you want to do something with the screenshot in the background)
        			@param [optional] (function) callback Called when response is received from server
        				@arg (object) response
        					@property (bool) success true if the screenshot was successfully posted, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        					@property (string) url URL pointing to the screenshot page on Clay.io
        					@property (string) imageSrc Direct URL to the image
        			@example ( new Clay.Screenshot() ).save( function( response ) {
        				console.log( response );
        			} );
        */

        var canvas,
          _this = this;
        if (this.id) {
          canvas = document.getElementById(this.id);
        } else {
          canvas = document.getElementsByTagName('canvas')[0];
        }
        if (!this.data) {
          this.data = canvas.toDataURL('image/png');
        }
        return exports.player.requireLogin(function() {
          var callbackId;
          if (callback) {
            callbackId = local.Callbacks.add(callback);
          }
          return local.Events.socketEmit('screenshot', 'save', {
            data: _this.data
          }, _this.instanceId, callbackId);
        }, true);
      };

      Screenshot.prototype.saveCallback = function(obj, callbackId) {
        if (callbackId) {
          local.Callbacks.execute(callbackId, [obj]);
        }
        if (obj.success) {
          return exports.UI.createNotification({
            title: 'Success!',
            html: 'Your screenshot was added to Clay.io'
          });
        } else {
          return exports.UI.createNotification({
            title: 'Error',
            html: obj.error
          });
        }
      };

      return Screenshot;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Stream = (function() {
      /*
      		Contains methods for anything related to logging statistics.
      		[Click here](http://clay.io/docs/analytics) for our Article Page on Analytics
      */

      function Stream() {
        this.instanceId = Math.random();
        local.Events.socketListen('stream', this);
      }

      Stream.prototype.post = function(options, callback) {
        var _this = this;
        if (callback == null) {
          callback = false;
        }
        /*
        			Posts a message to the user's Clay.io stream. They must be logged in for this to work. A login flow
        			is brought up if they are not logged in
        			@param [required] (object) options
        				@option (string) message The stream message to post
        				@option (boolean) editable If set to true, the user will be able to edit the message they are posting
        			@param [optional] (function) callback
        				@arg (object) response
        					@property (bool) success true if message was posted, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        			@example ( new Clay.Stream() ).post( { message: "Testing!", function( response ) {
        				if( !response.success )
        					console.log( "Error: " + response.error );
        			};
        */

        if (typeof options !== 'object') {
          exports.log('This form of passing post message is deprecated');
          options = {
            message: options
          };
        }
        return exports.player.requireLogin(function() {
          var a, callbackId, customElements, handler, html, text;
          if (callback) {
            callbackId = local.Callbacks.add(callback);
          }
          if (options.editable) {
            html = [];
            html.push("<textarea id='clay-share-message'>" + options.message + "</textarea>");
            html.push("<div id='clay-share-button'></div>");
            handler = function() {
              document.getElementById('clay-share-button-a').innerHTML = 'Loading...';
              _this.callback = function(obj) {
                exports.UI.closeModal('clay-share-wrapper');
                if (callback) {
                  return callback(obj);
                }
              };
              _this.post({
                message: document.getElementById('clay-share-message').value,
                editable: false
              });
              return false;
            };
            a = document.createElement('a');
            a.className = 'clay-button';
            a.id = 'clay-share-button-a';
            a.href = '#';
            text = document.createTextNode('Share');
            a.appendChild(text);
            customElements = [
              {
                parentElementId: 'clay-share-button',
                action: 'click',
                element: a,
                handler: handler
              }
            ];
            return Clay.UI.createModal({
              title: "Share Clay.io on Clay.io",
              html: html,
              id: 'clay-share-wrapper',
              customElements: customElements
            });
          } else {
            return local.Events.socketEmit('stream', 'post', options, _this.instanceId);
          }
          /*
          				local.Events.socketEmit( 'stream', 'post', options, @instanceId ); #, callbackId );
          */

        }, true);
      };

      Stream.prototype.postCallback = function(obj, callbackId) {
        exports.UI.createNotification({
          title: obj.title,
          html: obj.content
        });
        if (this.callback) {
          return this.callback(obj);
        }
      };

      return Stream;

    })();
  });

  namespace('Clay', function(exports) {
    return local.Social = (function() {

      function Social() {}

      Social.prototype.post = function(options, callback) {
        var _this = this;
        this.options = options;
        if (callback == null) {
          callback = false;
        }
        if (typeof this.options !== 'object') {
          exports.log('This form of passing post message is deprecated');
          this.options = {};
          this.options.message = options;
        }
        if (callback) {
          this.callback = callback;
        }
        return exports.player.requireLogin(function() {
          var a, customElements, handler, html, prettyType, text;
          if (_this.options.editable) {
            prettyType = _this.type === 'facebook' ? 'Facebook' : 'Twitter';
            html = [];
            html.push("<textarea id='clay-share-message'>" + _this.options.message + "</textarea>");
            html.push("<div id='clay-share-button'></div>");
            handler = function() {
              document.getElementById('clay-share-button-a').innerHTML = 'Loading...';
              _this.callback = function(obj) {
                exports.UI.closeModal('clay-share-wrapper');
                if (callback) {
                  return callback(obj);
                }
              };
              _this.post({
                message: document.getElementById('clay-share-message').value,
                editable: false
              });
              return false;
            };
            a = document.createElement('a');
            a.className = 'clay-button';
            a.id = 'clay-share-button-a';
            a.href = '#';
            text = document.createTextNode('Share');
            a.appendChild(text);
            customElements = [
              {
                parentElementId: 'clay-share-button',
                action: 'click',
                element: a,
                handler: handler
              }
            ];
            return Clay.UI.createModal({
              title: "Share Clay.io on " + prettyType,
              html: html,
              id: 'clay-share-wrapper',
              customElements: customElements
            });
          } else {
            return local.Events.socketEmit(_this.type, 'post', _this.options, _this.instanceId);
          }
        }, true);
      };

      Social.prototype.postCallback = function(obj) {
        if (!obj.error) {
          exports.UI.createNotification({
            title: obj.title,
            html: obj.content
          });
          local.Events.socketRemove(this.type, arguments.callee);
        }
        if (this.callback) {
          return this.callback(obj);
        }
      };

      Social.prototype.requestPermission = function(obj, callback) {
        var options, permissionCallback,
          _this = this;
        if (callback == null) {
          callback = false;
        }
        if (obj.type === 'clay') {
          options = {
            title: 'Grant Permissions',
            iframe: {
              src: exports.BASEURL + "/api/social/clay?site=" + this.type + "&id=" + Clay.gameID,
              id: "clay-" + this.type + "-iframe"
            },
            id: 'clay-' + this.type + '-wrapper'
          };
          exports.UI.createModal(options);
          permissionCallback = function(event) {
            var json;
            if (~exports.BASEURL.indexOf(event.origin)) {
              json = JSON.parse(event.data);
              if (json.success) {
                exports.UI.closeModal('clay-' + _this.type + '-wrapper');
                _this.options.reloadUser = true;
                _this.post(_this.options);
                return local.Events.removeEvent('message', arguments.callee);
              } else if (json.success === false) {
                exports.UI.closeModal('clay-' + _this.type + '-wrapper');
                return local.Events.removeEvent('message', arguments.callee);
              }
            }
          };
          return local.Events.addEvent('message', permissionCallback);
        } else {
          return this.connect(obj.use, function() {
            if (callback) {
              return callback();
            } else {
              _this.options.reloadUser = true;
              return _this.post(_this.options);
            }
          });
        }
      };

      Social.prototype.connect = function(use, callback) {
        var frame, linkCallback,
          _this = this;
        if (use == null) {
          use = 'clay';
        }
        if (callback == null) {
          callback = false;
        }
        use = use ? use : 'clay';
        frame = document.createElement('iframe');
        frame.src = exports.BASEURL + "/api/social/" + this.type + "?use=" + use;
        frame.frameBorder = '';
        frame.id = "clay-" + this.type + "-iframe";
        html.push("<iframe src='" + exports.BASEURL + "/api/social/" + this.type + "?use=" + use + "' class='' id='clay-" + this.type + "-iframe' />");
        exports.UI.addToContainer(frame);
        linkCallback = function(event) {
          var json;
          if (~exports.BASEURL.indexOf(event.origin)) {
            json = JSON.parse(event.data);
            if (json.success) {
              if (callback) {
                callback();
              }
            }
            if (json.success || json.hash) {
              exports.UI.removeElement('clay-' + _this.type + '-iframe');
              return local.Events.removeEvent('message', arguments.callee);
            } else if (json.popup) {
              return exports.UI.showPopupNotifier(json.popup);
            } else if (json.popupClose) {
              return exports.UI.hidePopupNotifier(json.popupClose);
            }
          }
        };
        return local.Events.addEvent('message', linkCallback);
      };

      return Social;

    })();
  });

  namespace('Clay', function(exports) {
    return exports.Twitter = (function(_super) {

      __extends(Twitter, _super);

      /*
      		Contains methods for anything related to making posts to Twitter. Must be instantiated with "new"
      		[Click here](http://clay.io/docs/social) for our Article Page on Twitter integration
      */


      function Twitter() {
        /*
        			There are no arguments to pass in the constructor
        */
        this.type = 'twitter';
        this.instanceId = Math.random();
        local.Events.socketListen("twitter", this, null, false);
      }

      Twitter.prototype.post = function(options, callback) {
        if (callback == null) {
          callback = false;
        }
        /*
        			Posts a Tweet. The user must be logged into Clay, and has granted your game
        			permission to post to their Twitter Account. If the user is either not logged in, or hasn't granted
        			permission, Clay.io will take care of all of that for you.
        			@param [required] (object) options
        				@option (boolean) editable If set to true, the user will be able to edit the message they are posting
        				@option (string) message A <= 140 character long message to tweet
        			@param [optional] (function) callback
        				@arg (object) response
        					@property (bool) success true if tweet was posted, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        			@example ( new Clay.Twitter() ).post( { message: "Testing!", function( response ) {
        				if( !response.success )
        					console.log( "Error: " + response.error );
        			};
        */

        return Twitter.__super__.post.call(this, options, callback);
      };

      return Twitter;

    })(local.Social);
  });

  namespace('Clay', function(exports) {
    return exports.Facebook = (function(_super) {

      __extends(Facebook, _super);

      /*
      		Contains methods for anything related to making posts to Facebook. Must be instantiated with "new"
      		[Click here](http://clay.io/docs/social) for our Article Page on Facebook integration
      */


      function Facebook() {
        /*
        			There are no arguments to pass in the constructor
        */
        this.type = 'facebook';
        this.instanceId = Math.random();
        local.Events.socketListen("facebook", this, null, false);
      }

      Facebook.prototype.post = function(options, callback) {
        if (callback == null) {
          callback = false;
        }
        /*
        			Posts a new stream item to Facebook. The user must be logged into Clay, and has granted your game
        			permission to post to their Facebook stream. If the user is either not logged in, or hasn't granted
        			permission, Clay.io will take care of all of that for you.
        			@param [required] (object) options You can pass any any of the options listed [here](http://developers.facebook.com/docs/reference/rest/stream.publish/)
        				@option (string) message A message to post (note, not all options are listed here, be sure to see the Facebook API docs linked to above)
        				@option (boolean) editable If set to true, the user will be able to edit the message they are posting
        			@param [optional] (function) callback
        				@arg (object) response
        					@property (bool) success true if stream message was posted, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        			@example ( new Clay.Facebook() ).post( { message: "Testing!" }, function( response ) {
        				if( !response.success )
        					console.log( "Error: " + response.error );
        			};
        */

        return Facebook.__super__.post.call(this, options, callback);
      };

      Facebook.invite = function(options, callback) {
        var caption, ele, html, listenCallback, modalOptions;
        if (options == null) {
          options = {};
        }
        if (callback == null) {
          callback = false;
        }
        /*
        			Connects with Facebook and lists the user's friends, allowing them to individually select friends to invite to play your game. 
        			Once they hit the "Invite" button, a message will be posted on their friends wall telling them about your game.
        			@param [required] (object) options
        				@option (string) caption The message that is posted to the users wall (along with a link to your game and the game's description). By default this is "Come play GAMENAME with me!"
        				@option (string) id DOM element id. If passed, the invite iframe will be put in that element. If not passed, it will be opened in the modal window.
        			@param [optional] (function) callback Called when at least one invite is successfully sent
        			@example Clay.Facebookinvite( { caption: "Come play me in this sweet game!" }, function() {
        				console.log( "Successfully posted!" );
        			};
        */

        html = [];
        caption = options.caption ? encodeURIComponent(options.caption) : '';
        html.push("<iframe src='" + exports.BASEURL + "/api/facebookinvite?id=" + exports.gameID + "&caption=" + caption + "' id='clay-facebook-invite-iframe' frameBorder='0'></iframe>");
        modalOptions = {
          title: 'Invite Your Friends',
          html: html,
          id: 'clay-facebook-invite-wrapper'
        };
        if (options.id && (ele = document.getElementById(options.id))) {
          ele.innerHTML = html.join('');
        } else {
          exports.UI.createModal(modalOptions);
        }
        listenCallback = function(event) {
          var json;
          if (~exports.BASEURL.indexOf(event.origin)) {
            json = JSON.parse(event.data);
            if (json.height) {
              ele = document.getElementById('clay-facebook-invite-iframe');
              ele.height = json.height;
              ele.style.height = json.height + 'px';
              return exports.UI.centerModal('clay-facebook-invite-wrapper');
            } else if (json.popup) {
              return exports.UI.showPopupNotifier(json.popup);
            } else if (json.popupClose) {
              return exports.UI.hidePopupNotifier(json.popupClose);
            } else if (json.success) {
              if (callback) {
                return callback({
                  success: true
                });
              }
            }
          }
        };
        return local.Events.addEvent('message', listenCallback);
      };

      return Facebook;

    })(local.Social);
  });

  namespace('Clay', function(exports) {
    exports.Achievement = (function() {
      /*
      		Contains methods for anything related to Clay.io achievements. Must be instantiated with "new"
      */

      exports.achievementsAwarded = {};

      Achievement.achievementObjs = {};

      function Achievement(options) {
        this.options = options;
        /*
        			@param [required] (object) options
        				@option (int) id Integer achievement ID. Given in developer dashboard for game after creating the achievement
        				@option (string) jwt JSON Web Token (hashed object) if you have the encryption option on for your game
        			@example new Clay.Achievement( { id: 1 } );
        */

        if (typeof this.options !== 'object') {
          exports.log('This form of passing achievement ID is deprecated');
          this.options = {
            id: this.options
          };
        }
        this.instanceId = Math.random();
        local.Events.socketListen("achievement", this);
      }

      Achievement.prototype.award = function(callback) {
        /*
        			Awards this object's achievement to a user. If they aren't logged into a Clay.io account,
        			it is stored with their IP Address and granted to them when they signup.
        			@param [optional] (function) callback
        				@arg (object) response
        					@property (bool) success true if achievement awarded, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        					@property (string) title Title of the achievement that was awarded
        					@property (string) description Description of the achievement that was awarded
        					@property (int) points The amount of points the achievement is worth
        					@property (truthy) icon False if no icon specified (in developer dashboard) or the full URL to the icon if it was specified 
        					@property (boolean) showExternally This is false if you set the option (in developer dashboard) to hide achievements when not playing from the Clay subdomain, true otherwise
        			@example ( new Clay.Achievement( { id: 1 } ) ).award( function( response ) {
        				if( response.success )
        					console.log( response.title + ": " response.description )
        				else
        					console.log( "Error: " + response.error );
        			};
        */

        var callbackId;
        if (!exports.achievementsAwarded[this.options.id]) {
          callbackId = local.Callbacks.add(callback);
          local.Events.socketEmit('achievement', 'award', this.options, this.instanceId, callbackId);
          return exports.achievementsAwarded[this.options.id] = true;
        }
      };

      Achievement.prototype.show = function(obj, callbackId) {
        var url;
        url = window.location !== window.parent.location ? document.referrer : document.location.href;
        if (obj.success && (~url.indexOf(exports.DOMAIN) || obj.showExternally)) {
          if (!obj.noUI) {
            if (exports.player.clearance !== 'clay') {
              obj.description += "<br /><a href='javascript: void( 0 );' onclick='Clay.player.login();'>Login</a> to claim";
            }
            exports.UI.createNotification({
              title: obj.title,
              html: obj.description,
              icon: obj.icon,
              type: 'achievement'
            });
          }
        }
        return local.Callbacks.execute(callbackId, [obj]);
      };

      Achievement.showAll = function(options, callback) {
        var callbackId;
        if (callback == null) {
          callback = false;
        }
        /*
        			Fetches all the achievements you've created for this game, and if the player has earned them or not.
        			This is good motivation for users to try and get the remaining achievements
        			@param [optional] (object) options - none to specify yet
        			@param [optional] (function) callback
        					@arg (object) response
        						@property (bool) success true if achievement awarded, false otherwise
        						@property (truthy) error Boolean false if no error, String error message if error
        						@property (string) title Title of the achievement that was awarded
        		
        			@example Clay.Achievement.fetchAll( {}, function( response ) {
        				console.log( response );
        			} );
        */

        if (callback) {
          callbackId = local.Callbacks.add(callback);
        }
        return local.Events.socketEmit('achievement', 'showAll', options, null, callbackId);
      };

      Achievement.fetchAll = function(options, callback) {
        if (options == null) {
          options = {};
        }
        if (callback == null) {
          callback = false;
        }
        /*
        			Shows all the achievements you've created for this game, and if the player has earned them or not.
        			This is good motivation for users to try and get the remaining achievements
        			@example Clay.Achievement.showAll();
        */

        options.fetch = true;
        return this.showAll(options, callback);
      };

      Achievement.showAllCallback = function(obj, callbackId) {
        var achievement, achievements, html, options, _i, _len;
        if (callbackId == null) {
          callbackId = false;
        }
        html = [];
        achievements = obj.data;
        for (_i = 0, _len = achievements.length; _i < _len; _i++) {
          achievement = achievements[_i];
          html.push("<div class='clay-achievement-single");
          if (achievement.icon) {
            html.push(" clay-achievement-with-icon");
          }
          if (achievement.earned) {
            html.push(" clay-achievement-single-achieved' title='You&#39;ve earned this achievement!'");
          }
          if (!achievement.earned) {
            html.push("' title='You haven&#39;t earned this achievement yet.'");
          }
          html.push(">");
          if (achievement.earned) {
            html.push("<div class='clay-checkmark-before'");
            if (achievement.icon) {
              html.push(" style='background-image: url( " + achievement.icon + " );'");
            }
            html.push("></div><div class='clay-checkmark'></div><div class='clay-checkmark-after'></div>");
          } else {
            html.push("<div class='clay-xmark-before'></div><div class='clay-xmark'></div><div class='clay-xmark-after'>&times;</div>");
          }
          html.push(achievement.title);
          html.push("<div class='clay-achievement-single-description'>" + achievement.description + "</div>");
          html.push("</div>");
        }
        options = {
          title: "Achievements",
          html: html,
          id: 'clay-achievements-wrapper'
        };
        exports.UI.createModal(options, function() {
          return document.querySelector('.clay-achievement-single-description').style.width = '100%';
        });
        if (callbackId) {
          return local.Callbacks.execute(callbackId, [obj]);
        }
      };

      Achievement.fetchAllCallback = function(obj, callbackId) {
        if (callbackId == null) {
          callbackId = false;
        }
        if (callbackId) {
          return local.Callbacks.execute(callbackId, [obj]);
        }
      };

      Achievement.prototype.requestFacebook = function(obj) {
        var callback,
          _this = this;
        if (!this.fb) {
          this.fb = new exports.Facebook();
        }
        callback = function() {
          return local.Events.socketEmit('achievement', 'facebook', obj, _this.instanceId);
        };
        return this.fb.requestPermission(obj, callback);
      };

      return Achievement;

    })();
    return exports.readyFunctions.push(function() {
      return local.Events.socketListen("achievement", exports.Achievement, false, false);
    });
  });

  namespace('Clay', function(exports) {
    return exports.Leaderboard = (function() {
      /*
      		Contains methods for anything related to Clay.io leaderboards. Must be instantiated with "new"
      		[Click here](http://clay.io/docs/leaderboards) for our Article Page on Leaderboards
      */

      function Leaderboard(options) {
        this.options = options;
        /*
        			@param [required] (object) options
        				@option (int) id Integer leaderboard ID. Given in developer dashboard for game after creating the leaderboard
        				@option (string) jwt JSON Web Token (hashed object) if you have the encryption option on for your game
        				@option (array) tabs An array of tab objects (a tab object can contain any of the options a typical leaderboard contains: id, data, filter, etc)
        				@option (string) html Custom HTML to show at the top of the leaderboard modal
        				@option (int) recent Specify an integer of seconds in the past to display scores from. ex. 3600 would show the last hour of scores
        				@option (array) filter An array of filters, similar to tabs, but can specify just a string for certain time intervals. ex. ['day', 'month', { title: "Custom Interval", recent: 7200 }]
        				@option (int) limit How many scores to show
        				@option (boolean) self Shows only scores by the person viewing the leaderboard if set to true
        				@option (boolean) friends Shows only scores by the friends of the person viewing the leaderboard if set to true
        				@option (boolean) cumulative Sums up all scores per unique person over the given interval
        				@option (boolean) showPersonal Displays personal stats like their best rank and score
        			@example new Clay.Leaderboard( { id: 1, tabs: [{ id: 2 }] } );
        */

        if (typeof this.options !== 'object') {
          exports.log('This form of passing leaderboard ID is deprecated');
          this.options = {
            id: this.options
          };
        }
        this.instanceId = Math.random();
        local.Events.socketListen("leaderboard", this);
      }

      Leaderboard.prototype.setData = function(options) {
        return this.options.data = options.data;
      };

      Leaderboard.prototype.fetch = function(options, callback) {
        if (options == null) {
          options = {};
        }
        if (callback == null) {
          callback = false;
        }
        /*
        			Retrieves an array of leaderboard objects (name, score)
        			If getRank is set to true, the response is an object with { data: [objects], rank: { rank: int, row: object } }
        			@param [required] (object) options If you pass these in the constructor, you don't need to again here
        				@option (int) id Integer leaderboard ID. Given in developer dashboard for game after creating the leaderboard
        				@option (int) recent Specify an integer of seconds in the past to fetch scores from. ex. 3600 would return the last hour of scores
        				@option (int) limit How many scores to show
        				@option (boolean) self Returns only scores by the person viewing the leaderboard if set to true
        				@option (boolean) friends Returns only scores by the friends of the person viewing the leaderboard if set to true
        				@option (boolean) cumulative Sums up all scores per unique person over the given interval
        				@option (boolean) getRank If true, this method returns an object instead of an array. The object consists of the data property that is the array of score objects, and a rank object that contains an integer rank property, and an object row property holding score and name
        			@example ( new Clay.Leaderboard( { id: 1 } ) ).fetch();
        */

        options.fetch = true;
        return this.show(options, callback);
      };

      Leaderboard.prototype.show = function(options, callback) {
        var callbackId;
        if (options == null) {
          options = {};
        }
        if (callback == null) {
          callback = false;
        }
        /*
        			Show the leaderboard modal window
        			@param [required] (object) options If you pass these in the constructor, you don't need to again here
        				@option (int) id Integer leaderboard ID. Given in developer dashboard for game after creating the leaderboard
        				@option (array) tabs An array of tab objects (a tab object can contain any of the options a typical leaderboard contains: id, data, filter, etc)
        				@option (string) html Custom HTML to show at the top of the leaderboard modal
        				@option (string) sort Accepts 'asc' or 'desc' to sort the scores either ascending or descending
        				@option (int) recent Specify an integer of seconds in the past to display scores from. ex. 3600 would show the last hour of scores
        				@option (array) filter An array of filters, similar to tabs, but can specify just a string for certain time intervals. ex. ['day', 'month', { title: "Custom Interval", recent: 7200 }]
        				@option (int) limit How many scores to show
        				@option (boolean) self Shows only scores by the person viewing the leaderboard if set to true
        				@option (boolean) friends Shows only scores by the friends of the person viewing the leaderboard if set to true
        				@option (boolean) cumulative Sums up all scores per unique person over the given interval
        				@option (boolean) showPersonal Displays personal stats like their best rank and score
        			@example ( new Clay.Leaderboard( { id: 1 } ) ).show();
        */

        if (this.options.id && !options.id) {
          options.id = this.options.id;
        }
        if (this.options.data && !options.data) {
          options.data = this.options.data;
        }
        if (this.options.tabs && !options.tabs) {
          options.tabs = this.options.tabs;
        }
        if (this.options.filters && !options.filters) {
          options.filters = this.options.filters;
        }
        this.prevTab = 0;
        this.tabs = {};
        if (callback) {
          callbackId = local.Callbacks.add(callback);
        }
        return local.Events.socketEmit('leaderboard', 'show', options, this.instanceId, callbackId);
      };

      Leaderboard.prototype.returnJSON = function(obj, callbackId) {
        var results;
        results = obj.data || {};
        if (obj.getRank) {
          results = {
            data: results,
            rank: obj.rank
          };
        }
        if (callbackId) {
          return local.Callbacks.execute(callbackId, [results]);
        }
      };

      Leaderboard.prototype.display = function(obj, callbackId) {
        var a, arrayOfCustomElements, ele, handler, header, i, leaderboard, options, position, subnavHTML, tab, table, tabs, text, width, _fn, _i, _j, _len, _len1, _ref, _ref1,
          _this = this;
        if (callbackId == null) {
          callbackId = false;
        }
        this.tabs[this.prevTab] = obj;
        leaderboard = [];
        if (!obj.name) {
          obj.name = '';
        }
        if (obj.requireLogin) {
          leaderboard.push("<p>You must <span id='clay-leaderboard-login'></span> to Clay.io to view your friends' scores</p>");
          a = document.createElement('a');
          a.href = '#';
          text = document.createTextNode('login');
          a.appendChild(text);
          handler = function() {
            exports.Player.login(function() {
              obj.reloadUser = true;
              obj.requireLogin = false;
              return _this.show(obj);
            });
            return false;
          };
          arrayOfCustomElements = [
            {
              parentElementId: 'clay-leaderboard-login',
              action: 'click',
              element: a,
              handler: handler
            }
          ];
        } else {
          if (obj.html) {
            leaderboard.push("<p class='clay-leaderboard-custom-html'>" + obj.html + "</p>");
          }
          if (obj.personal) {
            leaderboard.push("<div class='clay-leaderboard-personal' id='clay-leaderboard-personal-" + this.instanceId + "'>" + obj.personal + "</div>");
          }
          arrayOfCustomElements = [];
          tabs = [];
          if (obj.tabs.length > 1) {
            tabs.push("<ul class='clay-leaderboard-tabs'>");
            _ref = obj.tabs;
            _fn = function() {
              var index, link, localTab, onClick;
              link = document.createElement('a');
              text = document.createTextNode(tab.title);
              link.appendChild(text);
              index = i;
              localTab = tab;
              onClick = function() {
                localTab.index = index;
                return _this.setTab(localTab);
              };
              return arrayOfCustomElements.push( { parentElementId: 'clay-leaderboard-tab-' + i, element: link, handler: onClick } );
            };
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              tab = _ref[i];
              tabs.push("<li id='clay-leaderboard-tab-" + i + "'" + (this.prevTab === i ? " class='clay-leaderboard-tab-focus'" : '') + "></li>");
              _fn();
            }
            tabs.push("</ul>");
          }
          leaderboard.push("<div class='clay-leaderboard-table-wrapper' id='clay-leaderboard-table-" + this.instanceId + "'>");
          table = this.getTable(obj);
          leaderboard.push(table.html.join(""));
          leaderboard.push("</div>");
          if (table.customElements.length) {
            arrayOfCustomElements = arrayOfCustomElements.concat(table.customElements);
          }
          subnavHTML = '';
          subnavHTML += "<div class='clay-td-first' style='width: 15%'>Rank</div>";
          _ref1 = obj.header;
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            header = _ref1[i];
            if (i === obj.header.length - 1) {
              position = '-last';
            } else {
              position = '';
            }
            width = 85 / obj.header.length;
            if (header === 'Name') {
              width = Math.round(10 * width * 1.4) / 10;
            }
            if (header === 'Score') {
              width = Math.round(10 * width * 0.6) / 10;
            }
            subnavHTML += "<div class='clay-td" + position + "' style='width: " + width + "%'>" + header + "</div>";
          }
        }
        ele = document.getElementById('clay-leaderboard-wrapper');
        options = {
          title: obj.name || 'Leaderboard',
          html: leaderboard,
          id: 'clay-leaderboard-wrapper',
          customElements: arrayOfCustomElements,
          tabs: tabs,
          subnav: subnavHTML
        };
        if (ele && ele.style.display !== 'none') {
          exports.UI.updateModal(options);
        } else {
          exports.UI.createModal(options);
        }
        if (callbackId) {
          return local.Callbacks.execute(callbackId, [obj]);
        }
      };

      Leaderboard.prototype.hide = function() {
        /*
        			Hides the leaderboard modal
        			@example leaderboard.hide();
        */
        return exports.UI.closeModal('clay-leaderboard-wrapper');
      };

      Leaderboard.prototype.setTabs = function(options) {
        /*
        			Sets tabs for the leaderboard
        			@param [required] (object) options
        				@option (array) An array of tabs objects
        */
        return this.options.tabs = options.tabs;
      };

      Leaderboard.prototype.setTab = function(options) {
        var fromFilterBox, indicator, key, newTab, oldTab;
        fromFilterBox = typeof options.selected !== 'undefined';
        oldTab = document.getElementById('clay-leaderboard-tab-' + this.prevTab);
        if (oldTab && !fromFilterBox) {
          oldTab.className = '';
        }
        newTab = document.getElementById('clay-leaderboard-tab-' + options.index);
        if (newTab && !fromFilterBox) {
          newTab.className = 'clay-leaderboard-tab-focus';
        }
        indicator = document.getElementById('clay-leaderboard-wrapper-scroll-indicator');
        exports.UI.removeElement(indicator);
        this.prevTab = options.index;
        key = options.index + (fromFilterBox ? '-' + options.selected : '');
        this.prevTabFilter = key;
        if (this.tabs[key]) {
          this.setTabCallback(this.tabs[key]);
          return;
        }
        return local.Events.socketEmit('leaderboard', 'setTab', options, this.instanceId);
      };

      Leaderboard.prototype.setTabCallback = function(obj) {
        var ele, personal, table, _base1, _name;
        (_base1 = this.tabs)[_name = this.prevTabFilter] || (_base1[_name] = obj);
        table = this.getTable(obj);
        document.getElementById("clay-leaderboard-table-" + this.instanceId).innerHTML = table.html.join("");
        if (table.customElements.length) {
          exports.UI.customElements(table.customElements);
        }
        exports.UI.centerModal('clay-leaderboard-wrapper');
        personal = obj.personal || '';
        ele = document.getElementById("clay-leaderboard-personal-" + this.instanceId);
        if (ele) {
          return ele.innerHTML = personal;
        }
      };

      Leaderboard.prototype.removeEntry = function(options) {
        exports.UI.removeElement('clay-leaderboard-entry-' + options.id);
        return local.Events.socketEmit('leaderboard', 'removeEntry', options, this.instanceId);
      };

      Leaderboard.prototype.removeEntryCallback = function(obj) {
        if (obj.error) {
          return exports.log('There was an error deleting that leaderboard score! ' + obj.error);
        }
      };

      Leaderboard.prototype.share = function(obj) {
        var ele, entries, facebook, lsd, parent, rank, row, score, shareWrapper, text, twitter;
        ele = document.getElementById('clay-leaderboard-share-wrapper-' + obj.id);
        if (ele) {
          return ele.parentNode.removeChild(ele);
        } else {
          row = document.getElementById('clay-leaderboard-entry-' + obj.id);
          shareWrapper = document.createElement('div');
          shareWrapper.className = 'clay-share-score-wrapper';
          shareWrapper.id = 'clay-leaderboard-share-wrapper-' + obj.id;
          entries = document.getElementsByClassName('clay-leaderboard-entry');
          if (entries && entries[entries.length - 1].id === row.id) {
            shareWrapper.className += ' clay-share-score-wrapper-top';
          }
          score = row.getAttribute('data-score');
          rank = row.getAttribute('data-rank');
          lsd = rank.charAt(rank.length - 1);
          if (lsd === '1') {
            rank += 'st';
          } else if (lsd === '2') {
            rank += 'nd';
          } else if (lsd === '3') {
            rank += 'rd';
          } else {
            rank += 'th';
          }
          facebook = document.createElement('a');
          facebook.className = 'clay-share-score-facebook';
          facebook.href = '#';
          facebook.onclick = function(event) {
            (new exports.Facebook()).post({
              message: "I just scored " + score + " and am ranked " + rank + " in " + exports.Game.data.name + ". Think you can beat my score? " + window.location.href
            });
            ele = document.getElementById('clay-leaderboard-share-wrapper-' + obj.id);
            if (ele) {
              ele.parentNode.removeChild(ele);
            }
            return event.preventDefault();
          };
          text = document.createTextNode('Share on Facebook');
          facebook.appendChild(text);
          twitter = document.createElement('a');
          twitter.className = 'clay-share-score-twitter';
          twitter.href = '#';
          twitter.onclick = function(event) {
            (new exports.Twitter()).post({
              message: "I just scored " + score + " and am ranked " + rank + " in " + exports.Game.data.name + ". Think you can beat my score? " + window.location.href
            });
            ele = document.getElementById('clay-leaderboard-share-wrapper-' + obj.id);
            if (ele) {
              ele.parentNode.removeChild(ele);
            }
            return event.preventDefault();
          };
          text = document.createTextNode('Share on Twitter');
          twitter.appendChild(text);
          shareWrapper.appendChild(facebook);
          shareWrapper.appendChild(twitter);
          parent = document.getElementById('clay-leaderboard-share-' + obj.id);
          if (parent) {
            return setTimeout(function() {
              return parent.appendChild(shareWrapper);
            }, 0);
          }
        }
      };

      Leaderboard.prototype.getTable = function(obj) {
        var customElements, filter, filters, html, i, onChange, option, rank, row, text, trFromRow, _i, _j, _len, _len1, _ref, _ref1,
          _this = this;
        html = [];
        customElements = [];
        filters = null;
        if (obj.filters && obj.filters.length > 1) {
          filters = document.createElement('select');
          _ref = obj.filters;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            filter = _ref[i];
            option = document.createElement('option');
            option.value = i;
            if (filter.selected) {
              option.selected = true;
            }
            text = document.createTextNode(filter.title);
            option.appendChild(text);
            filters.appendChild(option);
          }
          onChange = function() {
            var newObj;
            newObj = JSON.parse(JSON.stringify(obj.filters[filters.value]));
            newObj.index = _this.prevTab || 0;
            newObj.selected = filters.value;
            return _this.setTab(newObj, filters.value);
          };
          customElements.push({
            parentElementId: 'clay-leaderboard-filters',
            action: 'change',
            element: filters,
            handler: onChange
          });
        }
        html.push("<table>");
        html.push("<thead>");
        if (filters) {
          html.push("<tr><th class='clay-leaderboard-filters' colspan='" + (obj.header.length + 1) + "'>");
          html.push("Filter by: <span id='clay-leaderboard-filters'></span>");
          html.push("</th></tr>");
        }
        html.push("</thead>");
        html.push("<tbody>");
        if (obj.data.length === 0 || obj.data[0].length === 0) {
          html.push("<tr><td colspan='" + obj.header.length + "'>No high scores yet!</td></tr>");
        } else {
          trFromRow = function(row, rank) {
            var id, shareButton, shareOnClick, width;
            html.push("<tr class='" + (row.me ? 'clay-leaderboard-me' : '') + " clay-leaderboard-entry' id='" + (row.id ? 'clay-leaderboard-entry-' + row.id : 'clay-leaderboard-entry-' + rank) + "' data-score='" + row.score + "' data-rank='" + rank + "'>");
            html.push("<td class='clay-leaderboard-rank' style='width: 15%;'>" + rank + "</td>");
            for (i in row) {
              text = row[i];
              if (i === 'me' || i === 'user_id' || i === 'id') {
                continue;
              }
              width = 85 / obj.header.length;
              if (i === 'name') {
                width = Math.round(10 * width * 1.4) / 10;
              }
              if (i === 'score') {
                width = Math.round(10 * width * 0.6) / 10;
              }
              html.push("<td style='width: " + width + "%;'>");
              html.push("<div class='relative'>");
              if (typeof text === 'number') {
                text = text.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
              }
              if (i === 'name' && row.user_id) {
                html.push("<img src='" + exports.BASEURL + "/avatar/" + row.user_id + "/40' /> ");
                html.push("<a href='" + exports.BASEURL + "/userid/" + row.user_id + "' class='clay-pad-link' target='_blank'>");
                html.push(local.htmlEntities(text));
                html.push("</a>");
              } else {
                if (obj.allowHTML) {
                  html.push(text);
                } else {
                  html.push(local.htmlEntities(text));
                }
                if (row.me && i === 'score') {
                  id = row.id || rank;
                  shareOnClick = function(event) {
                    _this.share({
                      id: id
                    });
                    event.preventDefault();
                    return event.stopPropagation();
                  };
                  html.push("<div id='clay-leaderboard-share-" + id + "' class='clay-share-score'></div>");
                  shareButton = document.createElement('a');
                  shareButton.href = '#';
                  shareButton.className = 'clay-share-score-link';
                  text = document.createTextNode('share');
                  shareButton.appendChild(text);
                  customElements.push({
                    parentElementId: 'clay-leaderboard-share-' + id,
                    action: 'click',
                    element: shareButton,
                    handler: shareOnClick
                  });
                }
                if (obj.admin && i === 'score') {
                  (function() {
                    var deleteButton, deleteOnClick;
                    id = row.id;
                    deleteOnClick = function() {
                      _this.removeEntry({
                        id: id
                      });
                      return false;
                    };
                    html.push("<span id='clay-leaderboard-remove-" + row.id + "'></span>");
                    deleteButton = document.createElement('a');
                    deleteButton.href = '#';
                    deleteButton.className = 'clay-close';
                    return customElements.push({
                      parentElementId: 'clay-leaderboard-remove-' + row.id,
                      action: 'click',
                      element: deleteButton,
                      handler: deleteOnClick
                    });
                  })();
                }
              }
              html.push("</div>");
              html.push("</td>");
            }
            return html.push("</tr>");
          };
          _ref1 = obj.data;
          for (rank = _j = 0, _len1 = _ref1.length; _j < _len1; rank = ++_j) {
            row = _ref1[rank];
            trFromRow(row, rank + 1);
          }
          if (obj.rank && obj.rank.rank > obj.data.length) {
            if (obj.rank.rank > obj.data.length + 1) {
              html.push("<tr class='clay-leaderboard-filler-row'><td colspan='" + (obj.header.length + 1) + "'>...</td></tr>");
            }
            trFromRow(obj.rank.row, obj.rank.rank);
          }
        }
        html.push("</tbody>");
        html.push("</table>");
        return {
          html: html,
          customElements: customElements
        };
      };

      Leaderboard.prototype.post = function(options, callback) {
        /*
        			Posts a score the this leaderboard object
        			@param [required] (object) options
        				@option (int) score
        				@option (string) name - If a name is passed, it will be used in the name column. Otherwise Clay.io will request login/their name to use (if not logged in)
        				@option (boolean) hideUI - if set to true, the leaderboard posted notification will not show
        			@param [optional] (function) callback
        				@arg (object) response
        					@property (bool) success true if score was posted, false otherwise
        					@property (truthy) error Boolean false if no error, String error message if error
        			@example ( new Clay.Achievement( { id: 1 } ) ).award( function( response ) {
        */

        var send,
          _this = this;
        send = function() {
          var callbackId;
          if (typeof options !== 'object') {
            exports.log('This form of passing leaderboard score is deprecated');
            options = {
              score: options
            };
          }
          options.id = _this.options.id;
          callbackId = local.Callbacks.add(callback);
          return local.Events.socketEmit('leaderboard', 'post', options, _this.instanceId, callbackId);
        };
        if (!options.name) {
          return exports.player.requireLogin(function() {
            return send();
          });
        } else {
          return send();
        }
      };

      Leaderboard.prototype.postCallback = function(obj, callbackId) {
        if (!obj.hideUI) {
          exports.UI.createNotification({
            title: obj.title,
            html: obj.content
          });
        }
        return local.Callbacks.execute(callbackId, [obj]);
      };

      Leaderboard.prototype.requestFacebook = function(obj) {
        var callback,
          _this = this;
        if (!this.fb) {
          this.fb = new exports.Facebook();
        }
        callback = function() {
          return local.Events.socketEmit('leaderboard', 'facebook', obj, _this.instanceId);
        };
        return this.fb.requestPermission(obj, callback);
      };

      return Leaderboard;

    })();
  });

}).call(this);
