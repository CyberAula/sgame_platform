/*! Built with IMPACT - impactjs.com */
(function(window) {
    "use strict";
    Number.prototype.map = function(istart, istop, ostart, ostop) {
        return ostart + (ostop - ostart) * ((this - istart) / (istop - istart));
    };
    Number.prototype.limit = function(min, max) {
        return Math.min(max, Math.max(min, this));
    };
    Number.prototype.round = function(precision) {
        precision = Math.pow(10, precision || 0);
        return Math.round(this * precision) / precision;
    };
    Number.prototype.floor = function() {
        return Math.floor(this);
    };
    Number.prototype.ceil = function() {
        return Math.ceil(this);
    };
    Number.prototype.toInt = function() {
        return (this | 0);
    };
    Number.prototype.toRad = function() {
        return (this / 180) * Math.PI;
    };
    Number.prototype.toDeg = function() {
        return (this * 180) / Math.PI;
    };
    Array.prototype.erase = function(item) {
        for (var i = this.length; i--;) {
            if (this[i] === item) {
                this.splice(i, 1);
            }
        }
        return this;
    };
    Array.prototype.random = function() {
        return this[Math.floor(Math.random() * this.length)];
    };
    Function.prototype.bind = Function.prototype.bind || function(oThis) {
        if (typeof this !== "function") {
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }
        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function() {},
            fBound = function() {
                return fToBind.apply((this instanceof fNOP && oThis ? this : oThis), aArgs.concat(Array.prototype.slice.call(arguments)));
            };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
    window.ig = {
        game: null,
        debug: null,
        version: '1.23',
        global: window,
        modules: {},
        resources: [],
        ready: false,
        baked: false,
        nocache: '',
        ua: {},
        prefix: (window.ImpactPrefix || ''),
        lib: 'lib/',
        _current: null,
        _loadQueue: [],
        _waitForOnload: 0,
        $: function(selector) {
            return selector.charAt(0) == '#' ? document.getElementById(selector.substr(1)) : document.getElementsByTagName(selector);
        },
        $new: function(name) {
            return document.createElement(name);
        },
        copy: function(object) {
            if (!object || typeof(object) != 'object' || object instanceof HTMLElement || object instanceof ig.Class) {
                return object;
            } else if (object instanceof Array) {
                var c = [];
                for (var i = 0, l = object.length; i < l; i++) {
                    c[i] = ig.copy(object[i]);
                }
                return c;
            } else {
                var c = {};
                for (var i in object) {
                    c[i] = ig.copy(object[i]);
                }
                return c;
            }
        },
        merge: function(original, extended) {
            for (var key in extended) {
                var ext = extended[key];
                if (typeof(ext) != 'object' || ext instanceof HTMLElement || ext instanceof ig.Class || ext === null) {
                    original[key] = ext;
                } else {
                    if (!original[key] || typeof(original[key]) != 'object') {
                        original[key] = (ext instanceof Array) ? [] : {};
                    }
                    ig.merge(original[key], ext);
                }
            }
            return original;
        },
        ksort: function(obj) {
            if (!obj || typeof(obj) != 'object') {
                return [];
            }
            var keys = [],
                values = [];
            for (var i in obj) {
                keys.push(i);
            }
            keys.sort();
            for (var i = 0; i < keys.length; i++) {
                values.push(obj[keys[i]]);
            }
            return values;
        },
        setVendorAttribute: function(el, attr, val) {
            var uc = attr.charAt(0).toUpperCase() + attr.substr(1);
            el[attr] = el['ms' + uc] = el['moz' + uc] = el['webkit' + uc] = el['o' + uc] = val;
        },
        getVendorAttribute: function(el, attr) {
            var uc = attr.charAt(0).toUpperCase() + attr.substr(1);
            return el[attr] || el['ms' + uc] || el['moz' + uc] || el['webkit' + uc] || el['o' + uc];
        },
        normalizeVendorAttribute: function(el, attr) {
            var prefixedVal = ig.getVendorAttribute(el, attr);
            if (!el[attr] && prefixedVal) {
                el[attr] = prefixedVal;
            }
        },
        getImagePixels: function(image, x, y, width, height) {
            var canvas = ig.$new('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            var ctx = canvas.getContext('2d');
            ig.System.SCALE.CRISP(canvas, ctx);
            var ratio = ig.getVendorAttribute(ctx, 'backingStorePixelRatio') || 1;
            ig.normalizeVendorAttribute(ctx, 'getImageDataHD');
            var realWidth = image.width / ratio,
                realHeight = image.height / ratio;
            canvas.width = Math.ceil(realWidth);
            canvas.height = Math.ceil(realHeight);
            ctx.drawImage(image, 0, 0, realWidth, realHeight);
            return (ratio === 1) ? ctx.getImageData(x, y, width, height) : ctx.getImageDataHD(x, y, width, height);
        },
        module: function(name) {
            if (ig._current) {
                throw ("Module '" + ig._current.name + "' defines nothing");
            }
            if (ig.modules[name] && ig.modules[name].body) {
                throw ("Module '" + name + "' is already defined");
            }
            ig._current = {
                name: name,
                requires: [],
                loaded: false,
                body: null
            };
            ig.modules[name] = ig._current;
            ig._loadQueue.push(ig._current);
            return ig;
        },
        requires: function() {
            ig._current.requires = Array.prototype.slice.call(arguments);
            return ig;
        },
        defines: function(body) {
            ig._current.body = body;
            ig._current = null;
            ig._initDOMReady();
        },
        addResource: function(resource) {
            ig.resources.push(resource);
        },
        setNocache: function(set) {
            ig.nocache = set ? '?' + Date.now() : '';
        },
        log: function() {},
        assert: function(condition, msg) {},
        show: function(name, number) {},
        mark: function(msg, color) {},
        _loadScript: function(name, requiredFrom) {
            ig.modules[name] = {
                name: name,
                requires: [],
                loaded: false,
                body: null
            };
            ig._waitForOnload++;
            var path = ig.prefix + ig.lib + name.replace(/\./g, '/') + '.js' + ig.nocache;
            var script = ig.$new('script');
            script.type = 'text/javascript';
            script.src = path;
            script.onload = function() {
                ig._waitForOnload--;
                ig._execModules();
            };
            script.onerror = function() {
                throw ('Failed to load module ' + name + ' at ' + path + ' ' + 'required from ' + requiredFrom);
            };
            ig.$('head')[0].appendChild(script);
        },
        _execModules: function() {
            var modulesLoaded = false;
            for (var i = 0; i < ig._loadQueue.length; i++) {
                var m = ig._loadQueue[i];
                var dependenciesLoaded = true;
                for (var j = 0; j < m.requires.length; j++) {
                    var name = m.requires[j];
                    if (!ig.modules[name]) {
                        dependenciesLoaded = false;
                        ig._loadScript(name, m.name);
                    } else if (!ig.modules[name].loaded) {
                        dependenciesLoaded = false;
                    }
                }
                if (dependenciesLoaded && m.body) {
                    ig._loadQueue.splice(i, 1);
                    m.loaded = true;
                    m.body();
                    modulesLoaded = true;
                    i--;
                }
            }
            if (modulesLoaded) {
                ig._execModules();
            } else if (!ig.baked && ig._waitForOnload == 0 && ig._loadQueue.length != 0) {
                var unresolved = [];
                for (var i = 0; i < ig._loadQueue.length; i++) {
                    var unloaded = [];
                    var requires = ig._loadQueue[i].requires;
                    for (var j = 0; j < requires.length; j++) {
                        var m = ig.modules[requires[j]];
                        if (!m || !m.loaded) {
                            unloaded.push(requires[j]);
                        }
                    }
                    unresolved.push(ig._loadQueue[i].name + ' (requires: ' + unloaded.join(', ') + ')');
                }
                throw ("Unresolved (or circular?) dependencies. " + "Most likely there's a name/path mismatch for one of the listed modules " + "or a previous syntax error prevents a module from loading:\n" +
                    unresolved.join('\n'));
            }
        },
        _DOMReady: function() {
            if (!ig.modules['dom.ready'].loaded) {
                if (!document.body) {
                    return setTimeout(ig._DOMReady, 13);
                }
                ig.modules['dom.ready'].loaded = true;
                ig._waitForOnload--;
                ig._execModules();
            }
            return 0;
        },
        _boot: function() {
            if (document.location.href.match(/\?nocache/)) {
                ig.setNocache(true);
            }
            ig.ua.pixelRatio = window.devicePixelRatio || 1;
            ig.ua.viewport = {
                width: window.innerWidth,
                height: window.innerHeight
            };
            ig.ua.screen = {
                width: window.screen.availWidth * ig.ua.pixelRatio,
                height: window.screen.availHeight * ig.ua.pixelRatio
            };
            ig.ua.iPhone = /iPhone/i.test(navigator.userAgent);
            ig.ua.iPhone4 = (ig.ua.iPhone && ig.ua.pixelRatio == 2);
            ig.ua.iPad = /iPad/i.test(navigator.userAgent);
            ig.ua.android = /android/i.test(navigator.userAgent);
            ig.ua.winPhone = /Windows Phone/i.test(navigator.userAgent);
            ig.ua.iOS = ig.ua.iPhone || ig.ua.iPad;
            ig.ua.mobile = ig.ua.iOS || ig.ua.android || ig.ua.winPhone || /mobile/i.test(navigator.userAgent);
            ig.ua.touchDevice = (('ontouchstart' in window) || (window.navigator.msMaxTouchPoints));
        },
        _initDOMReady: function() {
            if (ig.modules['dom.ready']) {
                ig._execModules();
                return;
            }
            ig._boot();
            ig.modules['dom.ready'] = {
                requires: [],
                loaded: false,
                body: null
            };
            ig._waitForOnload++;
            if (document.readyState === 'complete') {
                ig._DOMReady();
            } else {
                document.addEventListener('DOMContentLoaded', ig._DOMReady, false);
                window.addEventListener('load', ig._DOMReady, false);
            }
        }
    };
    ig.normalizeVendorAttribute(window, 'requestAnimationFrame');
    if (window.requestAnimationFrame) {
        var next = 1,
            anims = {};
        window.ig.setAnimation = function(callback, element) {
            var current = next++;
            anims[current] = true;
            var animate = function() {
                if (!anims[current]) {
                    return;
                }
                window.requestAnimationFrame(animate, element);
                callback();
            };
            window.requestAnimationFrame(animate, element);
            return current;
        };
        window.ig.clearAnimation = function(id) {
            delete anims[id];
        };
    } else {
        window.ig.setAnimation = function(callback, element) {
            return window.setInterval(callback, 1000 / 60);
        };
        window.ig.clearAnimation = function(id) {
            window.clearInterval(id);
        };
    }
    var initializing = false,
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\bparent\b/ : /.*/;
    var lastClassId = 0;
    window.ig.Class = function() {};
    var inject = function(prop) {
        var proto = this.prototype;
        var parent = {};
        for (var name in prop) {
            if (typeof(prop[name]) == "function" && typeof(proto[name]) == "function" && fnTest.test(prop[name])) {
                parent[name] = proto[name];
                proto[name] = (function(name, fn) {
                    return function() {
                        var tmp = this.parent;
                        this.parent = parent[name];
                        var ret = fn.apply(this, arguments);
                        this.parent = tmp;
                        return ret;
                    };
                })(name, prop[name]);
            } else {
                proto[name] = prop[name];
            }
        }
    };
    window.ig.Class.extend = function(prop) {
        var parent = this.prototype;
        initializing = true;
        var prototype = new this();
        initializing = false;
        for (var name in prop) {
            if (typeof(prop[name]) == "function" && typeof(parent[name]) == "function" && fnTest.test(prop[name])) {
                prototype[name] = (function(name, fn) {
                    return function() {
                        var tmp = this.parent;
                        this.parent = parent[name];
                        var ret = fn.apply(this, arguments);
                        this.parent = tmp;
                        return ret;
                    };
                })(name, prop[name]);
            } else {
                prototype[name] = prop[name];
            }
        }

        function Class() {
            if (!initializing) {
                if (this.staticInstantiate) {
                    var obj = this.staticInstantiate.apply(this, arguments);
                    if (obj) {
                        return obj;
                    }
                }
                for (var p in this) {
                    if (typeof(this[p]) == 'object') {
                        this[p] = ig.copy(this[p]);
                    }
                }
                if (this.init) {
                    this.init.apply(this, arguments);
                }
            }
            return this;
        }
        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.extend = window.ig.Class.extend;
        Class.inject = inject;
        Class.classId = prototype.classId = ++lastClassId;
        return Class;
    };
    if (window.ImpactMixin) {
        ig.merge(ig, window.ImpactMixin);
    }
})(window);

// lib/impact/image.js
ig.baked = true;
ig.module('impact.image').defines(function() {
    "use strict";
    ig.Image = ig.Class.extend({
        data: null,
        width: 0,
        height: 0,
        loaded: false,
        failed: false,
        loadCallback: null,
        path: '',
        staticInstantiate: function(path) {
            return ig.Image.cache[path] || null;
        },
        init: function(path) {
            this.path = path;
            this.load();
        },
        load: function(loadCallback) {
            if (this.loaded) {
                if (loadCallback) {
                    loadCallback(this.path, true);
                }
                return;
            } else if (!this.loaded && ig.ready) {
                this.loadCallback = loadCallback || null;
                this.data = new Image();
                this.data.onload = this.onload.bind(this);
                this.data.onerror = this.onerror.bind(this);
                this.data.src = ig.prefix + this.path + ig.nocache;
            } else {
                ig.addResource(this);
            }
            ig.Image.cache[this.path] = this;
        },
        reload: function() {
            this.loaded = false;
            this.data = new Image();
            this.data.onload = this.onload.bind(this);
            this.data.src = this.path + '?' + Date.now();
        },
        onload: function(event) {
            this.width = this.data.width;
            this.height = this.data.height;
            this.loaded = true;
            if (ig.system.scale != 1) {
                this.resize(ig.system.scale);
            }
            if (this.loadCallback) {
                this.loadCallback(this.path, true);
            }
        },
        onerror: function(event) {
            this.failed = true;
            if (this.loadCallback) {
                this.loadCallback(this.path, false);
            }
        },
        resize: function(scale) {
            var origPixels = ig.getImagePixels(this.data, 0, 0, this.width, this.height);
            var widthScaled = this.width * scale;
            var heightScaled = this.height * scale;
            var scaled = ig.$new('canvas');
            scaled.width = widthScaled;
            scaled.height = heightScaled;
            var scaledCtx = scaled.getContext('2d');
            var scaledPixels = scaledCtx.getImageData(0, 0, widthScaled, heightScaled);
            for (var y = 0; y < heightScaled; y++) {
                for (var x = 0; x < widthScaled; x++) {
                    var index = (Math.floor(y / scale) * this.width + Math.floor(x / scale)) * 4;
                    var indexScaled = (y * widthScaled + x) * 4;
                    scaledPixels.data[indexScaled] = origPixels.data[index];
                    scaledPixels.data[indexScaled + 1] = origPixels.data[index + 1];
                    scaledPixels.data[indexScaled + 2] = origPixels.data[index + 2];
                    scaledPixels.data[indexScaled + 3] = origPixels.data[index + 3];
                }
            }
            scaledCtx.putImageData(scaledPixels, 0, 0);
            this.data = scaled;
        },
        draw: function(targetX, targetY, sourceX, sourceY, width, height) {
            if (!this.loaded) {
                return;
            }
            var scale = ig.system.scale;
            sourceX = sourceX ? sourceX * scale : 0;
            sourceY = sourceY ? sourceY * scale : 0;
            width = (width ? width : this.width) * scale;
            height = (height ? height : this.height) * scale;
            ig.system.context.drawImage(this.data, sourceX, sourceY, width, height, ig.system.getDrawPos(targetX), ig.system.getDrawPos(targetY), width, height);
            ig.Image.drawCount++;
        },
        drawTile: function(targetX, targetY, tile, tileWidth, tileHeight, flipX, flipY) {
            tileHeight = tileHeight ? tileHeight : tileWidth;
            if (!this.loaded || tileWidth > this.width || tileHeight > this.height) {
                return;
            }
            var scale = ig.system.scale;
            var tileWidthScaled = Math.floor(tileWidth * scale);
            var tileHeightScaled = Math.floor(tileHeight * scale);
            var scaleX = flipX ? -1 : 1;
            var scaleY = flipY ? -1 : 1;
            if (flipX || flipY) {
                ig.system.context.save();
                ig.system.context.scale(scaleX, scaleY);
            }
            ig.system.context.drawImage(this.data, (Math.floor(tile * tileWidth) % this.width) * scale, (Math.floor(tile * tileWidth / this.width) * tileHeight) * scale, tileWidthScaled, tileHeightScaled, ig.system.getDrawPos(targetX) * scaleX - (flipX ? tileWidthScaled : 0), ig.system.getDrawPos(targetY) * scaleY - (flipY ? tileHeightScaled : 0), tileWidthScaled, tileHeightScaled);
            if (flipX || flipY) {
                ig.system.context.restore();
            }
            ig.Image.drawCount++;
        }
    });
    ig.Image.drawCount = 0;
    ig.Image.cache = {};
    ig.Image.reloadCache = function() {
        for (var path in ig.Image.cache) {
            ig.Image.cache[path].reload();
        }
    };
});

// lib/impact/font.js
ig.baked = true;
ig.module('impact.font').requires('impact.image').defines(function() {
    "use strict";
    ig.Font = ig.Image.extend({
        widthMap: [],
        indices: [],
        firstChar: 32,
        alpha: 1,
        letterSpacing: 1,
        lineSpacing: 0,
        onload: function(ev) {
            this._loadMetrics(this.data);
            this.parent(ev);
        },
        widthForString: function(text) {
            if (text.indexOf('\n') !== -1) {
                var lines = text.split('\n');
                var width = 0;
                for (var i = 0; i < lines.length; i++) {
                    width = Math.max(width, this._widthForLine(lines[i]));
                }
                return width;
            } else {
                return this._widthForLine(text);
            }
        },
        _widthForLine: function(text) {
            var width = 0;
            for (var i = 0; i < text.length; i++) {
                width += this.widthMap[text.charCodeAt(i) - this.firstChar] + this.letterSpacing;
            }
            return width;
        },
        heightForString: function(text) {
            return text.split('\n').length * (this.height + this.lineSpacing);
        },
        draw: function(text, x, y, align) {
            if (typeof(text) != 'string') {
                text = text.toString();
            }
            if (text.indexOf('\n') !== -1) {
                var lines = text.split('\n');
                var lineHeight = this.height + this.lineSpacing;
                for (var i = 0; i < lines.length; i++) {
                    this.draw(lines[i], x, y + i * lineHeight, align);
                }
                return;
            }
            if (align == ig.Font.ALIGN.RIGHT || align == ig.Font.ALIGN.CENTER) {
                var width = this._widthForLine(text);
                x -= align == ig.Font.ALIGN.CENTER ? width / 2 : width;
            }
            if (this.alpha !== 1) {
                ig.system.context.globalAlpha = this.alpha;
            }
            for (var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
                x += this._drawChar(c - this.firstChar, x, y);
            }
            if (this.alpha !== 1) {
                ig.system.context.globalAlpha = 1;
            }
            ig.Image.drawCount += text.length;
        },
        _drawChar: function(c, targetX, targetY) {
            if (!this.loaded || c < 0 || c >= this.indices.length) {
                return 0;
            }
            var scale = ig.system.scale;
            var charX = this.indices[c] * scale;
            var charY = 0;
            var charWidth = this.widthMap[c] * scale;
            var charHeight = (this.height - 2) * scale;
            ig.system.context.drawImage(this.data, charX, charY, charWidth, charHeight, ig.system.getDrawPos(targetX), ig.system.getDrawPos(targetY), charWidth, charHeight);
            return this.widthMap[c] + this.letterSpacing;
        },
        _loadMetrics: function(image) {
            this.height = image.height - 1;
            this.widthMap = [];
            this.indices = [];
            var px = ig.getImagePixels(image, 0, image.height - 1, image.width, 1);
            var currentChar = 0;
            var currentWidth = 0;
            for (var x = 0; x < image.width; x++) {
                var index = x * 4 + 3;
                if (px.data[index] > 127) {
                    currentWidth++;
                } else if (px.data[index] < 128 && currentWidth) {
                    this.widthMap.push(currentWidth);
                    this.indices.push(x - currentWidth);
                    currentChar++;
                    currentWidth = 0;
                }
            }
            this.widthMap.push(currentWidth);
            this.indices.push(x - currentWidth);
        }
    });
    ig.Font.ALIGN = {
        LEFT: 0,
        RIGHT: 1,
        CENTER: 2
    };
});

// lib/impact/sound.js
ig.baked = true;
ig.module('impact.sound').defines(function() {
    "use strict";
    ig.SoundManager = ig.Class.extend({
        clips: {},
        volume: 1,
        format: null,
        init: function() {
            if (!ig.Sound.enabled || !window.Audio) {
                ig.Sound.enabled = false;
                return;
            }
            var probe = new Audio();
            for (var i = 0; i < ig.Sound.use.length; i++) {
                var format = ig.Sound.use[i];
                if (probe.canPlayType(format.mime)) {
                    this.format = format;
                    break;
                }
            }
            if (!this.format) {
                ig.Sound.enabled = false;
            }
        },
        load: function(path, multiChannel, loadCallback) {
            var realPath = ig.prefix + path.replace(/[^\.]+$/, this.format.ext) + ig.nocache;
            if (this.clips[path]) {
                if (multiChannel && this.clips[path].length < ig.Sound.channels) {
                    for (var i = this.clips[path].length; i < ig.Sound.channels; i++) {
                        var a = new Audio(realPath);
                        a.load();
                        this.clips[path].push(a);
                    }
                }
                return this.clips[path][0];
            }
            var clip = new Audio(realPath);
            if (loadCallback) {
                clip.addEventListener('canplaythrough', function cb(ev) {
                    clip.removeEventListener('canplaythrough', cb, false);
                    loadCallback(path, true, ev);
                }, false);
                clip.addEventListener('error', function(ev) {
                    loadCallback(path, false, ev);
                }, false);
            }
            clip.preload = 'auto';
            clip.load();
            this.clips[path] = [clip];
            if (multiChannel) {
                for (var i = 1; i < ig.Sound.channels; i++) {
                    var a = new Audio(realPath);
                    a.load();
                    this.clips[path].push(a);
                }
            }
            return clip;
        },
        get: function(path) {
            var channels = this.clips[path];
            for (var i = 0, clip; clip = channels[i++];) {
                if (clip.paused || clip.ended) {
                    if (clip.ended) {
                        clip.currentTime = 0;
                    }
                    return clip;
                }
            }
            channels[0].pause();
            channels[0].currentTime = 0;
            return channels[0];
        }
    });
    ig.Music = ig.Class.extend({
        tracks: [],
        namedTracks: {},
        currentTrack: null,
        currentIndex: 0,
        random: false,
        _volume: 1,
        _loop: false,
        _fadeInterval: 0,
        _fadeTimer: null,
        _endedCallbackBound: null,
        init: function() {
            this._endedCallbackBound = this._endedCallback.bind(this);
            if (Object.defineProperty) {
                Object.defineProperty(this, "volume", {
                    get: this.getVolume.bind(this),
                    set: this.setVolume.bind(this)
                });
                Object.defineProperty(this, "loop", {
                    get: this.getLooping.bind(this),
                    set: this.setLooping.bind(this)
                });
            } else if (this.__defineGetter__) {
                this.__defineGetter__('volume', this.getVolume.bind(this));
                this.__defineSetter__('volume', this.setVolume.bind(this));
                this.__defineGetter__('loop', this.getLooping.bind(this));
                this.__defineSetter__('loop', this.setLooping.bind(this));
            }
        },
        add: function(music, name) {
            if (!ig.Sound.enabled) {
                return;
            }
            var path = music instanceof ig.Sound ? music.path : music;
            var track = ig.soundManager.load(path, false);
            track.loop = this._loop;
            track.volume = this._volume;
            track.addEventListener('ended', this._endedCallbackBound, false);
            this.tracks.push(track);
            if (name) {
                this.namedTracks[name] = track;
            }
            if (!this.currentTrack) {
                this.currentTrack = track;
            }
        },
        next: function() {
            if (!this.tracks.length) {
                return;
            }
            this.stop();
            this.currentIndex = this.random ? Math.floor(Math.random() * this.tracks.length) : (this.currentIndex + 1) % this.tracks.length;
            this.currentTrack = this.tracks[this.currentIndex];
            this.play();
        },
        pause: function() {
            if (!this.currentTrack) {
                return;
            }
            this.currentTrack.pause();
        },
        stop: function() {
            if (!this.currentTrack) {
                return;
            }
            this.currentTrack.pause();
            this.currentTrack.currentTime = 0;
        },
        play: function(name) {
            if (name && this.namedTracks[name]) {
                var newTrack = this.namedTracks[name];
                if (newTrack != this.currentTrack) {
                    this.stop();
                    this.currentTrack = newTrack;
                }
            } else if (!this.currentTrack) {
                return;
            }
            this.currentTrack.play();
        },
        getLooping: function() {
            return this._loop;
        },
        setLooping: function(l) {
            this._loop = l;
            for (var i in this.tracks) {
                this.tracks[i].loop = l;
            }
        },
        getVolume: function() {
            return this._volume;
        },
        setVolume: function(v) {
            this._volume = v.limit(0, 1);
            for (var i in this.tracks) {
                this.tracks[i].volume = this._volume;
            }
        },
        fadeOut: function(time) {
            if (!this.currentTrack) {
                return;
            }
            clearInterval(this._fadeInterval);
            this.fadeTimer = new ig.Timer(time);
            this._fadeInterval = setInterval(this._fadeStep.bind(this), 50);
        },
        _fadeStep: function() {
            var v = this.fadeTimer.delta().map(-this.fadeTimer.target, 0, 1, 0).limit(0, 1) * this._volume;
            if (v <= 0.01) {
                this.stop();
                this.currentTrack.volume = this._volume;
                clearInterval(this._fadeInterval);
            } else {
                this.currentTrack.volume = v;
            }
        },
        _endedCallback: function() {
            if (this._loop) {
                this.play();
            } else {
                this.next();
            }
        }
    });
    ig.Sound = ig.Class.extend({
        path: '',
        volume: 1,
        currentClip: null,
        multiChannel: true,
        init: function(path, multiChannel) {
            this.path = path;
            this.multiChannel = (multiChannel !== false);
            this.load();
        },
        load: function(loadCallback) {
            if (!ig.Sound.enabled) {
                if (loadCallback) {
                    loadCallback(this.path, true);
                }
                return;
            }
            if (ig.ready) {
                ig.soundManager.load(this.path, this.multiChannel, loadCallback);
            } else {
                ig.addResource(this);
            }
        },
        play: function() {
            if (!ig.Sound.enabled) {
                return;
            }
            this.currentClip = ig.soundManager.get(this.path);
            this.currentClip.volume = ig.soundManager.volume * this.volume;
            this.currentClip.play();
        },
        stop: function() {
            if (this.currentClip) {
                this.currentClip.pause();
                this.currentClip.currentTime = 0;
            }
        }
    });
    ig.Sound.FORMAT = {
        MP3: {
            ext: 'mp3',
            mime: 'audio/mpeg'
        },
        M4A: {
            ext: 'm4a',
            mime: 'audio/mp4; codecs=mp4a'
        },
        OGG: {
            ext: 'ogg',
            mime: 'audio/ogg; codecs=vorbis'
        },
        WEBM: {
            ext: 'webm',
            mime: 'audio/webm; codecs=vorbis'
        },
        CAF: {
            ext: 'caf',
            mime: 'audio/x-caf'
        }
    };
    ig.Sound.use = [ig.Sound.FORMAT.OGG, ig.Sound.FORMAT.MP3];
    ig.Sound.channels = 4;
    ig.Sound.enabled = true;
});

// lib/impact/loader.js
ig.baked = true;
ig.module('impact.loader').requires('impact.image', 'impact.font', 'impact.sound').defines(function() {
    "use strict";
    ig.Loader = ig.Class.extend({
        resources: [],
        gameClass: null,
        status: 0,
        done: false,
        _unloaded: [],
        _drawStatus: 0,
        _intervalId: 0,
        _loadCallbackBound: null,
        init: function(gameClass, resources) {
            this.gameClass = gameClass;
            this.resources = resources;
            this._loadCallbackBound = this._loadCallback.bind(this);
            for (var i = 0; i < this.resources.length; i++) {
                this._unloaded.push(this.resources[i].path);
            }
        },
        load: function() {
            ig.system.clear('#000');
            if (!this.resources.length) {
                this.end();
                return;
            }
            for (var i = 0; i < this.resources.length; i++) {
                this.loadResource(this.resources[i]);
            }
            this._intervalId = setInterval(this.draw.bind(this), 16);
        },
        loadResource: function(res) {
            res.load(this._loadCallbackBound);
        },
        end: function() {
            if (this.done) {
                return;
            }
            this.done = true;
            clearInterval(this._intervalId);
            ig.system.setGame(this.gameClass);
        },
        draw: function() {
            this._drawStatus += (this.status - this._drawStatus) / 5;
            var s = ig.system.scale;
            var w = ig.system.width * 0.6;
            var h = ig.system.height * 0.1;
            var x = ig.system.width * 0.5 - w / 2;
            var y = ig.system.height * 0.5 - h / 2;
            ig.system.context.fillStyle = '#000';
            ig.system.context.fillRect(0, 0, 480, 320);
            ig.system.context.fillStyle = '#fff';
            ig.system.context.fillRect(x * s, y * s, w * s, h * s);
            ig.system.context.fillStyle = '#000';
            ig.system.context.fillRect(x * s + s, y * s + s, w * s - s - s, h * s - s - s);
            ig.system.context.fillStyle = '#fff';
            ig.system.context.fillRect(x * s, y * s, w * s * this._drawStatus, h * s);
        },
        _loadCallback: function(path, status) {
            if (status) {
                this._unloaded.erase(path);
            } else {
                throw ('Failed to load resource: ' + path);
            }
            this.status = 1 - (this._unloaded.length / this.resources.length);
            if (this._unloaded.length == 0) {
                setTimeout(this.end.bind(this), 250);
            }
        }
    });
});

// lib/impact/timer.js
ig.baked = true;
ig.module('impact.timer').defines(function() {
    "use strict";
    ig.Timer = ig.Class.extend({
        target: 0,
        base: 0,
        last: 0,
        pausedAt: 0,
        init: function(seconds) {
            this.base = ig.Timer.time;
            this.last = ig.Timer.time;
            this.target = seconds || 0;
        },
        set: function(seconds) {
            this.target = seconds || 0;
            this.base = ig.Timer.time;
            this.pausedAt = 0;
        },
        reset: function() {
            this.base = ig.Timer.time;
            this.pausedAt = 0;
        },
        tick: function() {
            var delta = ig.Timer.time - this.last;
            this.last = ig.Timer.time;
            return (this.pausedAt ? 0 : delta);
        },
        delta: function() {
            return (this.pausedAt || ig.Timer.time) - this.base - this.target;
        },
        pause: function() {
            if (!this.pausedAt) {
                this.pausedAt = ig.Timer.time;
            }
        },
        unpause: function() {
            if (this.pausedAt) {
                this.base += ig.Timer.time - this.pausedAt;
                this.pausedAt = 0;
            }
        }
    });
    ig.Timer._last = 0;
    ig.Timer.time = Number.MIN_VALUE;
    ig.Timer.timeScale = 1;
    ig.Timer.maxStep = 0.05;
    ig.Timer.step = function() {
        var current = Date.now();
        var delta = (current - ig.Timer._last) / 1000;
        ig.Timer.time += Math.min(delta, ig.Timer.maxStep) * ig.Timer.timeScale;
        ig.Timer._last = current;
    };
});

// lib/impact/system.js
ig.baked = true;
ig.module('impact.system').requires('impact.timer', 'impact.image').defines(function() {
    "use strict";
    ig.System = ig.Class.extend({
        fps: 30,
        width: 320,
        height: 240,
        realWidth: 320,
        realHeight: 240,
        scale: 1,
        tick: 0,
        animationId: 0,
        newGameClass: null,
        running: false,
        delegate: null,
        clock: null,
        canvas: null,
        context: null,
        init: function(canvasId, fps, width, height, scale) {
            this.fps = fps;
            this.clock = new ig.Timer();
            this.canvas = ig.$(canvasId);
            this.resize(width, height, scale);
            this.context = this.canvas.getContext('2d');
            this.getDrawPos = ig.System.drawMode;
            if (this.scale != 1) {
                ig.System.scaleMode = ig.System.SCALE.CRISP;
            }
            ig.System.scaleMode(this.canvas, this.context);
        },
        resize: function(width, height, scale) {
            this.width = width;
            this.height = height;
            this.scale = scale || this.scale;
            this.realWidth = this.width * this.scale;
            this.realHeight = this.height * this.scale;
            this.canvas.width = this.realWidth;
            this.canvas.height = this.realHeight;
        },
        setGame: function(gameClass) {
            if (this.running) {
                this.newGameClass = gameClass;
            } else {
                this.setGameNow(gameClass);
            }
        },
        setGameNow: function(gameClass) {
            ig.game = new(gameClass)();
            ig.system.setDelegate(ig.game);
        },
        setDelegate: function(object) {
            if (typeof(object.run) == 'function') {
                this.delegate = object;
                this.startRunLoop();
            } else {
                throw ('System.setDelegate: No run() function in object');
            }
        },
        stopRunLoop: function() {
            ig.clearAnimation(this.animationId);
            this.running = false;
        },
        startRunLoop: function() {
            this.stopRunLoop();
            this.animationId = ig.setAnimation(this.run.bind(this), this.canvas);
            this.running = true;
        },
        clear: function(color) {
            this.context.fillStyle = color;
            this.context.fillRect(0, 0, this.realWidth, this.realHeight);
        },
        run: function() {
            ig.Timer.step();
            this.tick = this.clock.tick();
            this.delegate.run();
            ig.input.clearPressed();
            if (this.newGameClass) {
                this.setGameNow(this.newGameClass);
                this.newGameClass = null;
            }
        },
        getDrawPos: null
    });
    ig.System.DRAW = {
        AUTHENTIC: function(p) {
            return Math.round(p) * this.scale;
        },
        SMOOTH: function(p) {
            return Math.round(p * this.scale);
        },
        SUBPIXEL: function(p) {
            return p * this.scale;
        }
    };
    ig.System.drawMode = ig.System.DRAW.SMOOTH;
    ig.System.SCALE = {
        CRISP: function(canvas, context) {
            ig.setVendorAttribute(context, 'imageSmoothingEnabled', false);
            canvas.style.imageRendering = '-moz-crisp-edges';
            canvas.style.imageRendering = '-o-crisp-edges';
            canvas.style.imageRendering = '-webkit-optimize-contrast';
            canvas.style.imageRendering = 'crisp-edges';
            canvas.style.msInterpolationMode = 'nearest-neighbor';
        },
        SMOOTH: function(canvas, context) {
            ig.setVendorAttribute(context, 'imageSmoothingEnabled', true);
            canvas.style.imageRendering = '';
            canvas.style.msInterpolationMode = '';
        }
    };
    ig.System.scaleMode = ig.System.SCALE.SMOOTH;
});

// lib/impact/input.js
ig.baked = true;
ig.module('impact.input').defines(function() {
    "use strict";
    ig.KEY = {
        'MOUSE1': -1,
        'MOUSE2': -3,
        'MWHEEL_UP': -4,
        'MWHEEL_DOWN': -5,
        'BACKSPACE': 8,
        'TAB': 9,
        'ENTER': 13,
        'PAUSE': 19,
        'CAPS': 20,
        'ESC': 27,
        'SPACE': 32,
        'PAGE_UP': 33,
        'PAGE_DOWN': 34,
        'END': 35,
        'HOME': 36,
        'LEFT_ARROW': 37,
        'UP_ARROW': 38,
        'RIGHT_ARROW': 39,
        'DOWN_ARROW': 40,
        'INSERT': 45,
        'DELETE': 46,
        '_0': 48,
        '_1': 49,
        '_2': 50,
        '_3': 51,
        '_4': 52,
        '_5': 53,
        '_6': 54,
        '_7': 55,
        '_8': 56,
        '_9': 57,
        'A': 65,
        'B': 66,
        'C': 67,
        'D': 68,
        'E': 69,
        'F': 70,
        'G': 71,
        'H': 72,
        'I': 73,
        'J': 74,
        'K': 75,
        'L': 76,
        'M': 77,
        'N': 78,
        'O': 79,
        'P': 80,
        'Q': 81,
        'R': 82,
        'S': 83,
        'T': 84,
        'U': 85,
        'V': 86,
        'W': 87,
        'X': 88,
        'Y': 89,
        'Z': 90,
        'NUMPAD_0': 96,
        'NUMPAD_1': 97,
        'NUMPAD_2': 98,
        'NUMPAD_3': 99,
        'NUMPAD_4': 100,
        'NUMPAD_5': 101,
        'NUMPAD_6': 102,
        'NUMPAD_7': 103,
        'NUMPAD_8': 104,
        'NUMPAD_9': 105,
        'MULTIPLY': 106,
        'ADD': 107,
        'SUBSTRACT': 109,
        'DECIMAL': 110,
        'DIVIDE': 111,
        'F1': 112,
        'F2': 113,
        'F3': 114,
        'F4': 115,
        'F5': 116,
        'F6': 117,
        'F7': 118,
        'F8': 119,
        'F9': 120,
        'F10': 121,
        'F11': 122,
        'F12': 123,
        'SHIFT': 16,
        'CTRL': 17,
        'ALT': 18,
        'PLUS': 187,
        'COMMA': 188,
        'MINUS': 189,
        'PERIOD': 190
    };
    ig.Input = ig.Class.extend({
        bindings: {},
        actions: {},
        presses: {},
        locks: {},
        delayedKeyup: {},
        isUsingMouse: false,
        isUsingKeyboard: false,
        isUsingAccelerometer: false,
        mouse: {
            x: 0,
            y: 0
        },
        accel: {
            x: 0,
            y: 0,
            z: 0
        },
        initMouse: function() {
            if (this.isUsingMouse) {
                return;
            }
            this.isUsingMouse = true;
            var mouseWheelBound = this.mousewheel.bind(this);
            ig.system.canvas.addEventListener('mousewheel', mouseWheelBound, false);
            ig.system.canvas.addEventListener('DOMMouseScroll', mouseWheelBound, false);
            ig.system.canvas.addEventListener('contextmenu', this.contextmenu.bind(this), false);
            ig.system.canvas.addEventListener('mousedown', this.keydown.bind(this), false);
            ig.system.canvas.addEventListener('mouseup', this.keyup.bind(this), false);
            ig.system.canvas.addEventListener('mousemove', this.mousemove.bind(this), false);
            if (ig.ua.touchDevice) {
                ig.system.canvas.addEventListener('touchstart', this.keydown.bind(this), false);
                ig.system.canvas.addEventListener('touchend', this.keyup.bind(this), false);
                ig.system.canvas.addEventListener('touchmove', this.mousemove.bind(this), false);
                ig.system.canvas.addEventListener('MSPointerDown', this.keydown.bind(this), false);
                ig.system.canvas.addEventListener('MSPointerUp', this.keyup.bind(this), false);
                ig.system.canvas.addEventListener('MSPointerMove', this.mousemove.bind(this), false);
                ig.system.canvas.style.msTouchAction = 'none';
            }
        },
        initKeyboard: function() {
            if (this.isUsingKeyboard) {
                return;
            }
            this.isUsingKeyboard = true;
            window.addEventListener('keydown', this.keydown.bind(this), false);
            window.addEventListener('keyup', this.keyup.bind(this), false);
        },
        initAccelerometer: function() {
            if (this.isUsingAccelerometer) {
                return;
            }
            window.addEventListener('devicemotion', this.devicemotion.bind(this), false);
        },
        mousewheel: function(event) {
            var delta = event.wheelDelta ? event.wheelDelta : (event.detail * -1);
            var code = delta > 0 ? ig.KEY.MWHEEL_UP : ig.KEY.MWHEEL_DOWN;
            var action = this.bindings[code];
            if (action) {
                this.actions[action] = true;
                this.presses[action] = true;
                this.delayedKeyup[action] = true;
                event.stopPropagation();
                event.preventDefault();
            }
        },
        mousemove: function(event) {
            var internalWidth = parseInt(ig.system.canvas.offsetWidth) || ig.system.realWidth;
            var scale = ig.system.scale * (internalWidth / ig.system.realWidth);
            var pos = {
                left: 0,
                top: 0
            };
            if (ig.system.canvas.getBoundingClientRect) {
                pos = ig.system.canvas.getBoundingClientRect();
            }
            var ev = event.touches ? event.touches[0] : event;
            this.mouse.x = (ev.clientX - pos.left) / scale;
            this.mouse.y = (ev.clientY - pos.top) / scale;
        },
        contextmenu: function(event) {
            if (this.bindings[ig.KEY.MOUSE2]) {
                event.stopPropagation();
                event.preventDefault();
            }
        },
        keydown: function(event) {
            var tag = event.target.tagName;
            if (tag == 'INPUT' || tag == 'TEXTAREA') {
                return;
            }
            var code = event.type == 'keydown' ? event.keyCode : (event.button == 2 ? ig.KEY.MOUSE2 : ig.KEY.MOUSE1);
            if (event.type == 'touchstart' || event.type == 'mousedown') {
                this.mousemove(event);
            }
            var action = this.bindings[code];
            if (action) {
                this.actions[action] = true;
                if (!this.locks[action]) {
                    this.presses[action] = true;
                    this.locks[action] = true;
                }
                event.stopPropagation();
                event.preventDefault();
            }
        },
        keyup: function(event) {
            var tag = event.target.tagName;
            if (tag == 'INPUT' || tag == 'TEXTAREA') {
                return;
            }
            var code = event.type == 'keyup' ? event.keyCode : (event.button == 2 ? ig.KEY.MOUSE2 : ig.KEY.MOUSE1);
            var action = this.bindings[code];
            if (action) {
                this.delayedKeyup[action] = true;
                event.stopPropagation();
                event.preventDefault();
            }
        },
        devicemotion: function(event) {
            this.accel = event.accelerationIncludingGravity;
        },
        bind: function(key, action) {
            if (key < 0) {
                this.initMouse();
            } else if (key > 0) {
                this.initKeyboard();
            }
            this.bindings[key] = action;
        },
        bindTouch: function(selector, action) {
            var element = ig.$(selector);
            var that = this;
            element.addEventListener('touchstart', function(ev) {
                that.touchStart(ev, action);
            }, false);
            element.addEventListener('touchend', function(ev) {
                that.touchEnd(ev, action);
            }, false);
            element.addEventListener('MSPointerDown', function(ev) {
                that.touchStart(ev, action);
            }, false);
            element.addEventListener('MSPointerUp', function(ev) {
                that.touchEnd(ev, action);
            }, false);
        },
        unbind: function(key) {
            var action = this.bindings[key];
            this.delayedKeyup[action] = true;
            this.bindings[key] = null;
        },
        unbindAll: function() {
            this.bindings = {};
            this.actions = {};
            this.presses = {};
            this.locks = {};
            this.delayedKeyup = {};
        },
        state: function(action) {
            return this.actions[action];
        },
        pressed: function(action) {
            return this.presses[action];
        },
        released: function(action) {
            return !!this.delayedKeyup[action];
        },
        clearPressed: function() {
            for (var action in this.delayedKeyup) {
                this.actions[action] = false;
                this.locks[action] = false;
            }
            this.delayedKeyup = {};
            this.presses = {};
        },
        touchStart: function(event, action) {
            this.actions[action] = true;
            this.presses[action] = true;
            event.stopPropagation();
            event.preventDefault();
            return false;
        },
        touchEnd: function(event, action) {
            this.delayedKeyup[action] = true;
            event.stopPropagation();
            event.preventDefault();
            return false;
        }
    });
});

// lib/impact/impact.js
ig.baked = true;
ig.module('impact.impact').requires('dom.ready', 'impact.loader', 'impact.system', 'impact.input', 'impact.sound').defines(function() {
    "use strict";
    ig.main = function(canvasId, gameClass, fps, width, height, scale, loaderClass) {
        ig.system = new ig.System(canvasId, fps, width, height, scale || 1);
        ig.input = new ig.Input();
        ig.soundManager = new ig.SoundManager();
        ig.music = new ig.Music();
        ig.ready = true;
        var loader = new(loaderClass || ig.Loader)(gameClass, ig.resources);
        loader.load();
    };
});

// lib/impact/animation.js
ig.baked = true;
ig.module('impact.animation').requires('impact.timer', 'impact.image').defines(function() {
    "use strict";
    ig.AnimationSheet = ig.Class.extend({
        width: 8,
        height: 8,
        image: null,
        init: function(path, width, height) {
            this.width = width;
            this.height = height;
            this.image = new ig.Image(path);
        }
    });
    ig.Animation = ig.Class.extend({
        sheet: null,
        timer: null,
        sequence: [],
        flip: {
            x: false,
            y: false
        },
        pivot: {
            x: 0,
            y: 0
        },
        frame: 0,
        tile: 0,
        loopCount: 0,
        alpha: 1,
        angle: 0,
        init: function(sheet, frameTime, sequence, stop) {
            this.sheet = sheet;
            this.pivot = {
                x: sheet.width / 2,
                y: sheet.height / 2
            };
            this.timer = new ig.Timer();
            this.frameTime = frameTime;
            this.sequence = sequence;
            this.stop = !!stop;
            this.tile = this.sequence[0];
        },
        rewind: function() {
            this.timer.set();
            this.loopCount = 0;
            this.frame = 0;
            this.tile = this.sequence[0];
            return this;
        },
        gotoFrame: function(f) {
            this.timer.set(this.frameTime * -f - 0.0001);
            this.update();
        },
        gotoRandomFrame: function() {
            this.gotoFrame(Math.floor(Math.random() * this.sequence.length))
        },
        update: function() {
            var frameTotal = Math.floor(this.timer.delta() / this.frameTime);
            this.loopCount = Math.floor(frameTotal / this.sequence.length);
            if (this.stop && this.loopCount > 0) {
                this.frame = this.sequence.length - 1;
            } else {
                this.frame = frameTotal % this.sequence.length;
            }
            this.tile = this.sequence[this.frame];
        },
        draw: function(targetX, targetY) {
            var bbsize = Math.max(this.sheet.width, this.sheet.height);
            if (targetX > ig.system.width || targetY > ig.system.height || targetX + bbsize < 0 || targetY + bbsize < 0) {
                return;
            }
            if (this.alpha != 1) {
                ig.system.context.globalAlpha = this.alpha;
            }
            if (this.angle == 0) {
                this.sheet.image.drawTile(targetX, targetY, this.tile, this.sheet.width, this.sheet.height, this.flip.x, this.flip.y);
            } else {
                ig.system.context.save();
                ig.system.context.translate(ig.system.getDrawPos(targetX + this.pivot.x), ig.system.getDrawPos(targetY + this.pivot.y));
                ig.system.context.rotate(this.angle);
                this.sheet.image.drawTile(-this.pivot.x, -this.pivot.y, this.tile, this.sheet.width, this.sheet.height, this.flip.x, this.flip.y);
                ig.system.context.restore();
            }
            if (this.alpha != 1) {
                ig.system.context.globalAlpha = 1;
            }
        }
    });
});

// lib/impact/entity.js
ig.baked = true;
ig.module('impact.entity').requires('impact.animation', 'impact.impact').defines(function() {
    "use strict";
    ig.Entity = ig.Class.extend({
        id: 0,
        settings: {},
        size: {
            x: 16,
            y: 16
        },
        offset: {
            x: 0,
            y: 0
        },
        pos: {
            x: 0,
            y: 0
        },
        last: {
            x: 0,
            y: 0
        },
        vel: {
            x: 0,
            y: 0
        },
        accel: {
            x: 0,
            y: 0
        },
        friction: {
            x: 0,
            y: 0
        },
        maxVel: {
            x: 100,
            y: 100
        },
        zIndex: 0,
        gravityFactor: 1,
        standing: false,
        bounciness: 0,
        minBounceVelocity: 40,
        anims: {},
        animSheet: null,
        currentAnim: null,
        health: 10,
        type: 0,
        checkAgainst: 0,
        collides: 0,
        _killed: false,
        slopeStanding: {
            min: (44).toRad(),
            max: (136).toRad()
        },
        init: function(x, y, settings) {
            this.id = ++ig.Entity._lastId;
            this.pos.x = this.last.x = x;
            this.pos.y = this.last.y = y;
            ig.merge(this, settings);
        },
        reset: function(x, y, settings) {
            var proto = this.constructor.prototype;
            this.pos.x = x;
            this.pos.y = y;
            this.last.x = x;
            this.last.y = y;
            this.vel.x = proto.vel.x;
            this.vel.y = proto.vel.y;
            this.accel.x = proto.accel.x;
            this.accel.y = proto.accel.y;
            this.health = proto.health;
            this._killed = proto._killed;
            this.standing = proto.standing;
            this.type = proto.type;
            this.checkAgainst = proto.checkAgainst;
            this.collides = proto.collides;
            ig.merge(this, settings);
        },
        addAnim: function(name, frameTime, sequence, stop) {
            if (!this.animSheet) {
                throw ('No animSheet to add the animation ' + name + ' to.');
            }
            var a = new ig.Animation(this.animSheet, frameTime, sequence, stop);
            this.anims[name] = a;
            if (!this.currentAnim) {
                this.currentAnim = a;
            }
            return a;
        },
        update: function() {
            this.last.x = this.pos.x;
            this.last.y = this.pos.y;
            this.vel.y += ig.game.gravity * ig.system.tick * this.gravityFactor;
            this.vel.x = this.getNewVelocity(this.vel.x, this.accel.x, this.friction.x, this.maxVel.x);
            this.vel.y = this.getNewVelocity(this.vel.y, this.accel.y, this.friction.y, this.maxVel.y);
            var mx = this.vel.x * ig.system.tick;
            var my = this.vel.y * ig.system.tick;
            var res = ig.game.collisionMap.trace(this.pos.x, this.pos.y, mx, my, this.size.x, this.size.y);
            this.handleMovementTrace(res);
            if (this.currentAnim) {
                this.currentAnim.update();
            }
        },
        getNewVelocity: function(vel, accel, friction, max) {
            if (accel) {
                return (vel + accel * ig.system.tick).limit(-max, max);
            } else if (friction) {
                var delta = friction * ig.system.tick;
                if (vel - delta > 0) {
                    return vel - delta;
                } else if (vel + delta < 0) {
                    return vel + delta;
                } else {
                    return 0;
                }
            }
            return vel.limit(-max, max);
        },
        handleMovementTrace: function(res) {
            this.standing = false;
            if (res.collision.y) {
                if (this.bounciness > 0 && Math.abs(this.vel.y) > this.minBounceVelocity) {
                    this.vel.y *= -this.bounciness;
                } else {
                    if (this.vel.y > 0) {
                        this.standing = true;
                    }
                    this.vel.y = 0;
                }
            }
            if (res.collision.x) {
                if (this.bounciness > 0 && Math.abs(this.vel.x) > this.minBounceVelocity) {
                    this.vel.x *= -this.bounciness;
                } else {
                    this.vel.x = 0;
                }
            }
            if (res.collision.slope) {
                var s = res.collision.slope;
                if (this.bounciness > 0) {
                    var proj = this.vel.x * s.nx + this.vel.y * s.ny;
                    this.vel.x = (this.vel.x - s.nx * proj * 2) * this.bounciness;
                    this.vel.y = (this.vel.y - s.ny * proj * 2) * this.bounciness;
                } else {
                    var lengthSquared = s.x * s.x + s.y * s.y;
                    var dot = (this.vel.x * s.x + this.vel.y * s.y) / lengthSquared;
                    this.vel.x = s.x * dot;
                    this.vel.y = s.y * dot;
                    var angle = Math.atan2(s.x, s.y);
                    if (angle > this.slopeStanding.min && angle < this.slopeStanding.max) {
                        this.standing = true;
                    }
                }
            }
            this.pos = res.pos;
        },
        draw: function() {
            if (this.currentAnim) {
                this.currentAnim.draw(this.pos.x - this.offset.x - ig.game._rscreen.x, this.pos.y - this.offset.y - ig.game._rscreen.y);
            }
        },
        kill: function() {
            ig.game.removeEntity(this);
        },
        receiveDamage: function(amount, from) {
            this.health -= amount;
            if (this.health <= 0) {
                this.kill();
            }
        },
        touches: function(other) {
            return !(this.pos.x >= other.pos.x + other.size.x || this.pos.x + this.size.x <= other.pos.x || this.pos.y >= other.pos.y + other.size.y || this.pos.y + this.size.y <= other.pos.y);
        },
        distanceTo: function(other) {
            var xd = (this.pos.x + this.size.x / 2) - (other.pos.x + other.size.x / 2);
            var yd = (this.pos.y + this.size.y / 2) - (other.pos.y + other.size.y / 2);
            return Math.sqrt(xd * xd + yd * yd);
        },
        angleTo: function(other) {
            return Math.atan2((other.pos.y + other.size.y / 2) - (this.pos.y + this.size.y / 2), (other.pos.x + other.size.x / 2) - (this.pos.x + this.size.x / 2));
        },
        check: function(other) {},
        collideWith: function(other, axis) {},
        ready: function() {},
        erase: function() {}
    });
    ig.Entity._lastId = 0;
    ig.Entity.COLLIDES = {
        NEVER: 0,
        LITE: 1,
        PASSIVE: 2,
        ACTIVE: 4,
        FIXED: 8
    };
    ig.Entity.TYPE = {
        NONE: 0,
        A: 1,
        B: 2,
        BOTH: 3
    };
    ig.Entity.checkPair = function(a, b) {
        if (a.checkAgainst & b.type) {
            a.check(b);
        }
        if (b.checkAgainst & a.type) {
            b.check(a);
        }
        if (a.collides && b.collides && a.collides + b.collides > ig.Entity.COLLIDES.ACTIVE) {
            ig.Entity.solveCollision(a, b);
        }
    };
    ig.Entity.solveCollision = function(a, b) {
        var weak = null;
        if (a.collides == ig.Entity.COLLIDES.LITE || b.collides == ig.Entity.COLLIDES.FIXED) {
            weak = a;
        } else if (b.collides == ig.Entity.COLLIDES.LITE || a.collides == ig.Entity.COLLIDES.FIXED) {
            weak = b;
        }
        if (a.last.x + a.size.x > b.last.x && a.last.x < b.last.x + b.size.x) {
            if (a.last.y < b.last.y) {
                ig.Entity.seperateOnYAxis(a, b, weak);
            } else {
                ig.Entity.seperateOnYAxis(b, a, weak);
            }
            a.collideWith(b, 'y');
            b.collideWith(a, 'y');
        } else if (a.last.y + a.size.y > b.last.y && a.last.y < b.last.y + b.size.y) {
            if (a.last.x < b.last.x) {
                ig.Entity.seperateOnXAxis(a, b, weak);
            } else {
                ig.Entity.seperateOnXAxis(b, a, weak);
            }
            a.collideWith(b, 'x');
            b.collideWith(a, 'x');
        }
    };
    ig.Entity.seperateOnXAxis = function(left, right, weak) {
        var nudge = (left.pos.x + left.size.x - right.pos.x);
        if (weak) {
            var strong = left === weak ? right : left;
            weak.vel.x = -weak.vel.x * weak.bounciness + strong.vel.x;
            var resWeak = ig.game.collisionMap.trace(weak.pos.x, weak.pos.y, weak == left ? -nudge : nudge, 0, weak.size.x, weak.size.y);
            weak.pos.x = resWeak.pos.x;
        } else {
            var v2 = (left.vel.x - right.vel.x) / 2;
            left.vel.x = -v2;
            right.vel.x = v2;
            var resLeft = ig.game.collisionMap.trace(left.pos.x, left.pos.y, -nudge / 2, 0, left.size.x, left.size.y);
            left.pos.x = Math.floor(resLeft.pos.x);
            var resRight = ig.game.collisionMap.trace(right.pos.x, right.pos.y, nudge / 2, 0, right.size.x, right.size.y);
            right.pos.x = Math.ceil(resRight.pos.x);
        }
    };
    ig.Entity.seperateOnYAxis = function(top, bottom, weak) {
        var nudge = (top.pos.y + top.size.y - bottom.pos.y);
        if (weak) {
            var strong = top === weak ? bottom : top;
            weak.vel.y = -weak.vel.y * weak.bounciness + strong.vel.y;
            var nudgeX = 0;
            if (weak == top && Math.abs(weak.vel.y - strong.vel.y) < weak.minBounceVelocity) {
                weak.standing = true;
                nudgeX = strong.vel.x * ig.system.tick;
            }
            var resWeak = ig.game.collisionMap.trace(weak.pos.x, weak.pos.y, nudgeX, weak == top ? -nudge : nudge, weak.size.x, weak.size.y);
            weak.pos.y = resWeak.pos.y;
            weak.pos.x = resWeak.pos.x;
        } else if (ig.game.gravity && (bottom.standing || top.vel.y > 0)) {
            var resTop = ig.game.collisionMap.trace(top.pos.x, top.pos.y, 0, -(top.pos.y + top.size.y - bottom.pos.y), top.size.x, top.size.y);
            top.pos.y = resTop.pos.y;
            if (top.bounciness > 0 && top.vel.y > top.minBounceVelocity) {
                top.vel.y *= -top.bounciness;
            } else {
                top.standing = true;
                top.vel.y = 0;
            }
        } else {
            var v2 = (top.vel.y - bottom.vel.y) / 2;
            top.vel.y = -v2;
            bottom.vel.y = v2;
            var nudgeX = bottom.vel.x * ig.system.tick;
            var resTop = ig.game.collisionMap.trace(top.pos.x, top.pos.y, nudgeX, -nudge / 2, top.size.x, top.size.y);
            top.pos.y = resTop.pos.y;
            var resBottom = ig.game.collisionMap.trace(bottom.pos.x, bottom.pos.y, 0, nudge / 2, bottom.size.x, bottom.size.y);
            bottom.pos.y = resBottom.pos.y;
        }
    };
});

// lib/impact/map.js
ig.baked = true;
ig.module('impact.map').defines(function() {
    "use strict";
    ig.Map = ig.Class.extend({
        tilesize: 8,
        width: 1,
        height: 1,
        data: [
            []
        ],
        name: null,
        init: function(tilesize, data) {
            this.tilesize = tilesize;
            this.data = data;
            this.height = data.length;
            this.width = data[0].length;
            this.pxWidth = this.width * this.tilesize;
            this.pxHeight = this.height * this.tilesize;
        },
        getTile: function(x, y) {
            var tx = Math.floor(x / this.tilesize);
            var ty = Math.floor(y / this.tilesize);
            if ((tx >= 0 && tx < this.width) && (ty >= 0 && ty < this.height)) {
                return this.data[ty][tx];
            } else {
                return 0;
            }
        },
        setTile: function(x, y, tile) {
            var tx = Math.floor(x / this.tilesize);
            var ty = Math.floor(y / this.tilesize);
            if ((tx >= 0 && tx < this.width) && (ty >= 0 && ty < this.height)) {
                this.data[ty][tx] = tile;
            }
        }
    });
});

// lib/impact/collision-map.js
ig.baked = true;
ig.module('impact.collision-map').requires('impact.map').defines(function() {
    "use strict";
    ig.CollisionMap = ig.Map.extend({
        lastSlope: 1,
        tiledef: null,
        init: function(tilesize, data, tiledef) {
            this.parent(tilesize, data);
            this.tiledef = tiledef || ig.CollisionMap.defaultTileDef;
            for (var t in this.tiledef) {
                if (t | 0 > this.lastSlope) {
                    this.lastSlope = t | 0;
                }
            }
        },
        trace: function(x, y, vx, vy, objectWidth, objectHeight) {
            var res = {
                collision: {
                    x: false,
                    y: false,
                    slope: false
                },
                pos: {
                    x: x,
                    y: y
                },
                tile: {
                    x: 0,
                    y: 0
                }
            };
            var steps = Math.ceil(Math.max(Math.abs(vx), Math.abs(vy)) / this.tilesize);
            if (steps > 1) {
                var sx = vx / steps;
                var sy = vy / steps;
                for (var i = 0; i < steps && (sx || sy); i++) {
                    this._traceStep(res, x, y, sx, sy, objectWidth, objectHeight, vx, vy, i);
                    x = res.pos.x;
                    y = res.pos.y;
                    if (res.collision.x) {
                        sx = 0;
                        vx = 0;
                    }
                    if (res.collision.y) {
                        sy = 0;
                        vy = 0;
                    }
                    if (res.collision.slope) {
                        break;
                    }
                }
            } else {
                this._traceStep(res, x, y, vx, vy, objectWidth, objectHeight, vx, vy, 0);
            }
            return res;
        },
        _traceStep: function(res, x, y, vx, vy, width, height, rvx, rvy, step) {
            res.pos.x += vx;
            res.pos.y += vy;
            var t = 0;
            if (vx) {
                var pxOffsetX = (vx > 0 ? width : 0);
                var tileOffsetX = (vx < 0 ? this.tilesize : 0);
                var firstTileY = Math.max(Math.floor(y / this.tilesize), 0);
                var lastTileY = Math.min(Math.ceil((y + height) / this.tilesize), this.height);
                var tileX = Math.floor((res.pos.x + pxOffsetX) / this.tilesize);
                var prevTileX = Math.floor((x + pxOffsetX) / this.tilesize);
                if (step > 0 || tileX == prevTileX || prevTileX < 0 || prevTileX >= this.width) {
                    prevTileX = -1;
                }
                if (tileX >= 0 && tileX < this.width) {
                    for (var tileY = firstTileY; tileY < lastTileY; tileY++) {
                        if (prevTileX != -1) {
                            t = this.data[tileY][prevTileX];
                            if (t > 1 && t <= this.lastSlope && this._checkTileDef(res, t, x, y, rvx, rvy, width, height, prevTileX, tileY)) {
                                break;
                            }
                        }
                        t = this.data[tileY][tileX];
                        if (t == 1 || t > this.lastSlope || (t > 1 && this._checkTileDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY))) {
                            if (t > 1 && t <= this.lastSlope && res.collision.slope) {
                                break;
                            }
                            res.collision.x = true;
                            res.tile.x = t;
                            x = res.pos.x = tileX * this.tilesize - pxOffsetX + tileOffsetX;
                            rvx = 0;
                            break;
                        }
                    }
                }
            }
            if (vy) {
                var pxOffsetY = (vy > 0 ? height : 0);
                var tileOffsetY = (vy < 0 ? this.tilesize : 0);
                var firstTileX = Math.max(Math.floor(res.pos.x / this.tilesize), 0);
                var lastTileX = Math.min(Math.ceil((res.pos.x + width) / this.tilesize), this.width);
                var tileY = Math.floor((res.pos.y + pxOffsetY) / this.tilesize);
                var prevTileY = Math.floor((y + pxOffsetY) / this.tilesize);
                if (step > 0 || tileY == prevTileY || prevTileY < 0 || prevTileY >= this.height) {
                    prevTileY = -1;
                }
                if (tileY >= 0 && tileY < this.height) {
                    for (var tileX = firstTileX; tileX < lastTileX; tileX++) {
                        if (prevTileY != -1) {
                            t = this.data[prevTileY][tileX];
                            if (t > 1 && t <= this.lastSlope && this._checkTileDef(res, t, x, y, rvx, rvy, width, height, tileX, prevTileY)) {
                                break;
                            }
                        }
                        t = this.data[tileY][tileX];
                        if (t == 1 || t > this.lastSlope || (t > 1 && this._checkTileDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY))) {
                            if (t > 1 && t <= this.lastSlope && res.collision.slope) {
                                break;
                            }
                            res.collision.y = true;
                            res.tile.y = t;
                            res.pos.y = tileY * this.tilesize - pxOffsetY + tileOffsetY;
                            break;
                        }
                    }
                }
            }
        },
        _checkTileDef: function(res, t, x, y, vx, vy, width, height, tileX, tileY) {
            var def = this.tiledef[t];
            if (!def) {
                return false;
            }
            var lx = (tileX + def[0]) * this.tilesize,
                ly = (tileY + def[1]) * this.tilesize,
                lvx = (def[2] - def[0]) * this.tilesize,
                lvy = (def[3] - def[1]) * this.tilesize,
                solid = def[4];
            var tx = x + vx + (lvy < 0 ? width : 0) - lx,
                ty = y + vy + (lvx > 0 ? height : 0) - ly;
            if (lvx * ty - lvy * tx > 0) {
                if (vx * -lvy + vy * lvx < 0) {
                    return solid;
                }
                var length = Math.sqrt(lvx * lvx + lvy * lvy);
                var nx = lvy / length,
                    ny = -lvx / length;
                var proj = tx * nx + ty * ny;
                var px = nx * proj,
                    py = ny * proj;
                if (px * px + py * py >= vx * vx + vy * vy) {
                    return solid || (lvx * (ty - vy) - lvy * (tx - vx) < 0.5);
                }
                res.pos.x = x + vx - px;
                res.pos.y = y + vy - py;
                res.collision.slope = {
                    x: lvx,
                    y: lvy,
                    nx: nx,
                    ny: ny
                };
                return true;
            }
            return false;
        }
    });
    var H = 1 / 2,
        N = 1 / 3,
        M = 2 / 3,
        SOLID = true,
        NON_SOLID = false;
    ig.CollisionMap.defaultTileDef = {
        5: [0, 1, 1, M, SOLID],
        6: [0, M, 1, N, SOLID],
        7: [0, N, 1, 0, SOLID],
        3: [0, 1, 1, H, SOLID],
        4: [0, H, 1, 0, SOLID],
        2: [0, 1, 1, 0, SOLID],
        10: [H, 1, 1, 0, SOLID],
        21: [0, 1, H, 0, SOLID],
        32: [M, 1, 1, 0, SOLID],
        43: [N, 1, M, 0, SOLID],
        54: [0, 1, N, 0, SOLID],
        27: [0, 0, 1, N, SOLID],
        28: [0, N, 1, M, SOLID],
        29: [0, M, 1, 1, SOLID],
        25: [0, 0, 1, H, SOLID],
        26: [0, H, 1, 1, SOLID],
        24: [0, 0, 1, 1, SOLID],
        11: [0, 0, H, 1, SOLID],
        22: [H, 0, 1, 1, SOLID],
        33: [0, 0, N, 1, SOLID],
        44: [N, 0, M, 1, SOLID],
        55: [M, 0, 1, 1, SOLID],
        16: [1, N, 0, 0, SOLID],
        17: [1, M, 0, N, SOLID],
        18: [1, 1, 0, M, SOLID],
        14: [1, H, 0, 0, SOLID],
        15: [1, 1, 0, H, SOLID],
        13: [1, 1, 0, 0, SOLID],
        8: [H, 1, 0, 0, SOLID],
        19: [1, 1, H, 0, SOLID],
        30: [N, 1, 0, 0, SOLID],
        41: [M, 1, N, 0, SOLID],
        52: [1, 1, M, 0, SOLID],
        38: [1, M, 0, 1, SOLID],
        39: [1, N, 0, M, SOLID],
        40: [1, 0, 0, N, SOLID],
        36: [1, H, 0, 1, SOLID],
        37: [1, 0, 0, H, SOLID],
        35: [1, 0, 0, 1, SOLID],
        9: [1, 0, H, 1, SOLID],
        20: [H, 0, 0, 1, SOLID],
        31: [1, 0, M, 1, SOLID],
        42: [M, 0, N, 1, SOLID],
        53: [N, 0, 0, 1, SOLID],
        12: [0, 0, 1, 0, NON_SOLID],
        23: [1, 1, 0, 1, NON_SOLID],
        34: [1, 0, 1, 1, NON_SOLID],
        45: [0, 1, 0, 0, NON_SOLID]
    };
    ig.CollisionMap.staticNoCollision = {
        trace: function(x, y, vx, vy) {
            return {
                collision: {
                    x: false,
                    y: false,
                    slope: false
                },
                pos: {
                    x: x + vx,
                    y: y + vy
                },
                tile: {
                    x: 0,
                    y: 0
                }
            };
        }
    };
});

// lib/impact/background-map.js
ig.baked = true;
ig.module('impact.background-map').requires('impact.map', 'impact.image').defines(function() {
    "use strict";
    ig.BackgroundMap = ig.Map.extend({
        tiles: null,
        scroll: {
            x: 0,
            y: 0
        },
        distance: 1,
        repeat: false,
        tilesetName: '',
        foreground: false,
        enabled: true,
        preRender: false,
        preRenderedChunks: null,
        chunkSize: 512,
        debugChunks: false,
        anims: {},
        init: function(tilesize, data, tileset) {
            this.parent(tilesize, data);
            this.setTileset(tileset);
        },
        setTileset: function(tileset) {
            this.tilesetName = tileset instanceof ig.Image ? tileset.path : tileset;
            this.tiles = new ig.Image(this.tilesetName);
            this.preRenderedChunks = null;
        },
        setScreenPos: function(x, y) {
            this.scroll.x = x / this.distance;
            this.scroll.y = y / this.distance;
        },
        preRenderMapToChunks: function() {
            var totalWidth = this.width * this.tilesize * ig.system.scale,
                totalHeight = this.height * this.tilesize * ig.system.scale;
            this.chunkSize = Math.min(Math.max(totalWidth, totalHeight), this.chunkSize);
            var chunkCols = Math.ceil(totalWidth / this.chunkSize),
                chunkRows = Math.ceil(totalHeight / this.chunkSize);
            this.preRenderedChunks = [];
            for (var y = 0; y < chunkRows; y++) {
                this.preRenderedChunks[y] = [];
                for (var x = 0; x < chunkCols; x++) {
                    var chunkWidth = (x == chunkCols - 1) ? totalWidth - x * this.chunkSize : this.chunkSize;
                    var chunkHeight = (y == chunkRows - 1) ? totalHeight - y * this.chunkSize : this.chunkSize;
                    this.preRenderedChunks[y][x] = this.preRenderChunk(x, y, chunkWidth, chunkHeight);
                }
            }
        },
        preRenderChunk: function(cx, cy, w, h) {
            var tw = w / this.tilesize / ig.system.scale + 1,
                th = h / this.tilesize / ig.system.scale + 1;
            var nx = (cx * this.chunkSize / ig.system.scale) % this.tilesize,
                ny = (cy * this.chunkSize / ig.system.scale) % this.tilesize;
            var tx = Math.floor(cx * this.chunkSize / this.tilesize / ig.system.scale),
                ty = Math.floor(cy * this.chunkSize / this.tilesize / ig.system.scale);
            var chunk = ig.$new('canvas');
            chunk.width = w;
            chunk.height = h;
            chunk.retinaResolutionEnabled = false;
            var chunkContext = chunk.getContext('2d');
            ig.System.scaleMode(chunk, chunkContext);
            var screenContext = ig.system.context;
            ig.system.context = chunkContext;
            for (var x = 0; x < tw; x++) {
                for (var y = 0; y < th; y++) {
                    if (x + tx < this.width && y + ty < this.height) {
                        var tile = this.data[y + ty][x + tx];
                        if (tile) {
                            this.tiles.drawTile(x * this.tilesize - nx, y * this.tilesize - ny, tile - 1, this.tilesize);
                        }
                    }
                }
            }
            ig.system.context = screenContext;
            return chunk;
        },
        draw: function() {
            if (!this.tiles.loaded || !this.enabled) {
                return;
            }
            if (this.preRender) {
                this.drawPreRendered();
            } else {
                this.drawTiled();
            }
        },
        drawPreRendered: function() {
            if (!this.preRenderedChunks) {
                this.preRenderMapToChunks();
            }
            var dx = ig.system.getDrawPos(this.scroll.x),
                dy = ig.system.getDrawPos(this.scroll.y);
            if (this.repeat) {
                var w = this.width * this.tilesize * ig.system.scale;
                dx = (dx % w + w) % w;
                var h = this.height * this.tilesize * ig.system.scale;
                dy = (dy % h + h) % h;
            }
            var minChunkX = Math.max(Math.floor(dx / this.chunkSize), 0),
                minChunkY = Math.max(Math.floor(dy / this.chunkSize), 0),
                maxChunkX = Math.ceil((dx + ig.system.realWidth) / this.chunkSize),
                maxChunkY = Math.ceil((dy + ig.system.realHeight) / this.chunkSize),
                maxRealChunkX = this.preRenderedChunks[0].length,
                maxRealChunkY = this.preRenderedChunks.length;
            if (!this.repeat) {
                maxChunkX = Math.min(maxChunkX, maxRealChunkX);
                maxChunkY = Math.min(maxChunkY, maxRealChunkY);
            }
            var nudgeY = 0;
            for (var cy = minChunkY; cy < maxChunkY; cy++) {
                var nudgeX = 0;
                for (var cx = minChunkX; cx < maxChunkX; cx++) {
                    var chunk = this.preRenderedChunks[cy % maxRealChunkY][cx % maxRealChunkX];
                    var x = -dx + cx * this.chunkSize - nudgeX;
                    var y = -dy + cy * this.chunkSize - nudgeY;
                    ig.system.context.drawImage(chunk, x, y);
                    ig.Image.drawCount++;
                    if (this.debugChunks) {
                        ig.system.context.strokeStyle = '#f0f';
                        ig.system.context.strokeRect(x, y, this.chunkSize, this.chunkSize);
                    }
                    if (this.repeat && chunk.width < this.chunkSize && x + chunk.width < ig.system.realWidth) {
                        nudgeX += this.chunkSize - chunk.width;
                        maxChunkX++;
                    }
                }
                if (this.repeat && chunk.height < this.chunkSize && y + chunk.height < ig.system.realHeight) {
                    nudgeY += this.chunkSize - chunk.height;
                    maxChunkY++;
                }
            }
        },
        drawTiled: function() {
            var tile = 0,
                anim = null,
                tileOffsetX = (this.scroll.x / this.tilesize).toInt(),
                tileOffsetY = (this.scroll.y / this.tilesize).toInt(),
                pxOffsetX = this.scroll.x % this.tilesize,
                pxOffsetY = this.scroll.y % this.tilesize,
                pxMinX = -pxOffsetX - this.tilesize,
                pxMinY = -pxOffsetY - this.tilesize,
                pxMaxX = ig.system.width + this.tilesize - pxOffsetX,
                pxMaxY = ig.system.height + this.tilesize - pxOffsetY;
            for (var mapY = -1, pxY = pxMinY; pxY < pxMaxY; mapY++, pxY += this.tilesize) {
                var tileY = mapY + tileOffsetY;
                if (tileY >= this.height || tileY < 0) {
                    if (!this.repeat) {
                        continue;
                    }
                    tileY = (tileY % this.height + this.height) % this.height;
                }
                for (var mapX = -1, pxX = pxMinX; pxX < pxMaxX; mapX++, pxX += this.tilesize) {
                    var tileX = mapX + tileOffsetX;
                    if (tileX >= this.width || tileX < 0) {
                        if (!this.repeat) {
                            continue;
                        }
                        tileX = (tileX % this.width + this.width) % this.width;
                    }
                    if ((tile = this.data[tileY][tileX])) {
                        if ((anim = this.anims[tile - 1])) {
                            anim.draw(pxX, pxY);
                        } else {
                            this.tiles.drawTile(pxX, pxY, tile - 1, this.tilesize);
                        }
                    }
                }
            }
        }
    });
});

// lib/impact/game.js
ig.baked = true;
ig.module('impact.game').requires('impact.impact', 'impact.entity', 'impact.collision-map', 'impact.background-map').defines(function() {
    "use strict";
    ig.Game = ig.Class.extend({
        clearColor: '#000000',
        gravity: 0,
        screen: {
            x: 0,
            y: 0
        },
        _rscreen: {
            x: 0,
            y: 0
        },
        entities: [],
        namedEntities: {},
        collisionMap: ig.CollisionMap.staticNoCollision,
        backgroundMaps: [],
        backgroundAnims: {},
        autoSort: false,
        sortBy: null,
        cellSize: 64,
        _deferredKill: [],
        _levelToLoad: null,
        _doSortEntities: false,
        staticInstantiate: function() {
            this.sortBy = this.sortBy || ig.Game.SORT.Z_INDEX;
            ig.game = this;
            return null;
        },
        loadLevel: function(data) {
            this.screen = {
                x: 0,
                y: 0
            };
            this.entities = [];
            this.namedEntities = {};
            for (var i = 0; i < data.entities.length; i++) {
                var ent = data.entities[i];
                this.spawnEntity(ent.type, ent.x, ent.y, ent.settings);
            }
            this.sortEntities();
            this.collisionMap = ig.CollisionMap.staticNoCollision;
            this.backgroundMaps = [];
            for (var i = 0; i < data.layer.length; i++) {
                var ld = data.layer[i];
                if (ld.name == 'collision') {
                    this.collisionMap = new ig.CollisionMap(ld.tilesize, ld.data);
                } else {
                    var newMap = new ig.BackgroundMap(ld.tilesize, ld.data, ld.tilesetName);
                    newMap.anims = this.backgroundAnims[ld.tilesetName] || {};
                    newMap.repeat = ld.repeat;
                    newMap.distance = ld.distance;
                    newMap.foreground = !!ld.foreground;
                    newMap.preRender = !!ld.preRender;
                    newMap.name = ld.name;
                    this.backgroundMaps.push(newMap);
                }
            }
            for (var i = 0; i < this.entities.length; i++) {
                this.entities[i].ready();
            }
        },
        loadLevelDeferred: function(data) {
            this._levelToLoad = data;
        },
        getMapByName: function(name) {
            if (name == 'collision') {
                return this.collisionMap;
            }
            for (var i = 0; i < this.backgroundMaps.length; i++) {
                if (this.backgroundMaps[i].name == name) {
                    return this.backgroundMaps[i];
                }
            }
            return null;
        },
        getEntityByName: function(name) {
            return this.namedEntities[name];
        },
        getEntitiesByType: function(type) {
            var entityClass = typeof(type) === 'string' ? ig.global[type] : type;
            var a = [];
            for (var i = 0; i < this.entities.length; i++) {
                var ent = this.entities[i];
                if (ent instanceof entityClass && !ent._killed) {
                    a.push(ent);
                }
            }
            return a;
        },
        spawnEntity: function(type, x, y, settings) {
            var entityClass = typeof(type) === 'string' ? ig.global[type] : type;
            if (!entityClass) {
                throw ("Can't spawn entity of type " + type);
            }
            var ent = new(entityClass)(x, y, settings || {});
            this.entities.push(ent);
            if (ent.name) {
                this.namedEntities[ent.name] = ent;
            }
            return ent;
        },
        sortEntities: function() {
            this.entities.sort(this.sortBy);
        },
        sortEntitiesDeferred: function() {
            this._doSortEntities = true;
        },
        removeEntity: function(ent) {
            if (ent.name) {
                delete this.namedEntities[ent.name];
            }
            ent._killed = true;
            ent.type = ig.Entity.TYPE.NONE;
            ent.checkAgainst = ig.Entity.TYPE.NONE;
            ent.collides = ig.Entity.COLLIDES.NEVER;
            this._deferredKill.push(ent);
        },
        run: function() {
            this.update();
            this.draw();
        },
        update: function() {
            if (this._levelToLoad) {
                this.loadLevel(this._levelToLoad);
                this._levelToLoad = null;
            }
            this.updateEntities();
            this.checkEntities();
            for (var i = 0; i < this._deferredKill.length; i++) {
                this._deferredKill[i].erase();
                this.entities.erase(this._deferredKill[i]);
            }
            this._deferredKill = [];
            if (this._doSortEntities || this.autoSort) {
                this.sortEntities();
                this._doSortEntities = false;
            }
            for (var tileset in this.backgroundAnims) {
                var anims = this.backgroundAnims[tileset];
                for (var a in anims) {
                    anims[a].update();
                }
            }
        },
        updateEntities: function() {
            for (var i = 0; i < this.entities.length; i++) {
                var ent = this.entities[i];
                if (!ent._killed) {
                    ent.update();
                }
            }
        },
        draw: function() {
            if (this.clearColor) {
                ig.system.clear(this.clearColor);
            }
            this._rscreen.x = ig.system.getDrawPos(this.screen.x) / ig.system.scale;
            this._rscreen.y = ig.system.getDrawPos(this.screen.y) / ig.system.scale;
            var mapIndex;
            for (mapIndex = 0; mapIndex < this.backgroundMaps.length; mapIndex++) {
                var map = this.backgroundMaps[mapIndex];
                if (map.foreground) {
                    break;
                }
                map.setScreenPos(this.screen.x, this.screen.y);
                map.draw();
            }
            this.drawEntities();
            for (mapIndex; mapIndex < this.backgroundMaps.length; mapIndex++) {
                var map = this.backgroundMaps[mapIndex];
                map.setScreenPos(this.screen.x, this.screen.y);
                map.draw();
            }
        },
        drawEntities: function() {
            for (var i = 0; i < this.entities.length; i++) {
                this.entities[i].draw();
            }
        },
        checkEntities: function() {
            var hash = {};
            for (var e = 0; e < this.entities.length; e++) {
                var entity = this.entities[e];
                if (entity.type == ig.Entity.TYPE.NONE && entity.checkAgainst == ig.Entity.TYPE.NONE && entity.collides == ig.Entity.COLLIDES.NEVER) {
                    continue;
                }
                var checked = {},
                    xmin = Math.floor(entity.pos.x / this.cellSize),
                    ymin = Math.floor(entity.pos.y / this.cellSize),
                    xmax = Math.floor((entity.pos.x + entity.size.x) / this.cellSize) + 1,
                    ymax = Math.floor((entity.pos.y + entity.size.y) / this.cellSize) + 1;
                for (var x = xmin; x < xmax; x++) {
                    for (var y = ymin; y < ymax; y++) {
                        if (!hash[x]) {
                            hash[x] = {};
                            hash[x][y] = [entity];
                        } else if (!hash[x][y]) {
                            hash[x][y] = [entity];
                        } else {
                            var cell = hash[x][y];
                            for (var c = 0; c < cell.length; c++) {
                                if (entity.touches(cell[c]) && !checked[cell[c].id]) {
                                    checked[cell[c].id] = true;
                                    ig.Entity.checkPair(entity, cell[c]);
                                }
                            }
                            cell.push(entity);
                        }
                    }
                }
            }
        }
    });
    ig.Game.SORT = {
        Z_INDEX: function(a, b) {
            return a.zIndex - b.zIndex;
        },
        POS_X: function(a, b) {
            return (a.pos.x + a.size.x) - (b.pos.x + b.size.x);
        },
        POS_Y: function(a, b) {
            return (a.pos.y + a.size.y) - (b.pos.y + b.size.y);
        }
    };
});

// lib/plugins/parallax.js
ig.baked = true;
ig.module('plugins.parallax').requires('impact.image').defines(function() {
    Parallax = ig.Class.extend({
        layers: [],
        screen: {
            x: 0,
            y: 0
        },
        init: function(settings) {
            ig.merge(this, settings);
        },
        add: function(path, settings) {
            var layer = new ParallaxLayer(path, settings);
            this.layers.push(layer);
        },
        move: function(x) {
            this.screen.x += (x * ig.system.tick);
        },
        draw: function() {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                var x = -((this.screen.x / layer.distance) % layer.w);
                if (this.screen.x <= 0) x = x - layer.w;
                layer.x = x;
                while (layer.x < ig.system.width) {
                    layer.draw();
                    layer.x += layer.w;
                }
                layer.x = x;
            }
        }
    });
    ParallaxLayer = ig.Class.extend({
        distance: 0,
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        img: null,
        init: function(path, settings) {
            if (settings && settings.distance == 0) settings.distance = 1;
            this.img = new ig.Image(path);
            this.w = this.img.width;
            this.h = this.img.height;
            ig.merge(this, settings);
        },
        draw: function() {
            this.img.draw(this.x, this.y);
        }
    })
});

// lib/plugins/impact-splash-loader.js
ig.baked = true;
ig.module('plugins.impact-splash-loader').requires('impact.loader').defines(function() {
    ig.ImpactSplashLoader = ig.Loader.extend({
        endTime: 0,
        fadeToWhiteTime: 200,
        fadeToGameTime: 800,
        logoWidth: 340,
        logoHeight: 120,
        end: function() {
            this.parent();
            this.endTime = Date.now();
            ig.system.setDelegate(this);
        },
        run: function() {
            var t = Date.now() - this.endTime;
            var alpha = 1;
            if (t < this.fadeToWhiteTime) {
                this.draw();
                alpha = t.map(0, this.fadeToWhiteTime, 0, 1);
            } else if (t < this.fadeToGameTime) {
                ig.game.run();
                alpha = t.map(this.fadeToWhiteTime, this.fadeToGameTime, 1, 0);
            } else {
                ig.system.setDelegate(ig.game);
                return;
            }
            ig.system.context.fillStyle = 'rgba(255,255,255,' + alpha + ')';
            ig.system.context.fillRect(0, 0, ig.system.realWidth, ig.system.realHeight);
        },
        draw: function() {
            this._drawStatus += (this.status - this._drawStatus) / 5;
            var ctx = ig.system.context;
            var w = ig.system.realWidth;
            var h = ig.system.realHeight;
            var scale = w / this.logoWidth / 3;
            var center = (w - this.logoWidth * scale) / 2;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, w, h);
            var loadingScreen = new Image();
            loadingScreen.src = "data:image/png;base64,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";
            ctx.drawImage(loadingScreen, 0, 0);
            ctx.save();
            ctx.translate(center, h / 1.9);
            ctx.scale(scale, scale);
            ctx.lineWidth = '3';
            ctx.strokeStyle = 'rgb(255,255,255)';
            ctx.strokeRect(25, this.logoHeight + 40, 300, 20);
            ctx.fillStyle = 'rgb(255,255,255)';
            ctx.fillRect(30, this.logoHeight + 45, 290 * this._drawStatus, 10);
            ctx.restore();
        },
        drawPaths: function(color, paths) {
            var ctx = ig.system.context;
            ctx.fillStyle = color;
            for (var i = 0; i < paths.length; i += 2) {
                ctx[ig.ImpactSplashLoader.OPS[paths[i]]].apply(ctx, paths[i + 1]);
            }
        }
    });
    ig.ImpactSplashLoader.OPS = {
        bp: 'beginPath',
        cp: 'closePath',
        f: 'fill',
        m: 'moveTo',
        l: 'lineTo',
        bc: 'bezierCurveTo'
    };
});

// lib/plugins/canvas-css3-scaling.js
ig.baked = true;
ig.module('plugins.canvas-css3-scaling').requires('impact.input').defines(function() {
    CanvasCSS3Scaling = ig.Class.extend({
        offset: null,
        scale: null,
        init: function() {
            this.element = document.getElementById('game');
            this.canvas = this.element.firstElementChild;
            this.content = [this.canvas.width, this.canvas.height];
            window.addEventListener('resize', this, false);
            window.addEventListener('orientationchange', this, false);
            this.reflow();
            ig.Input.inject({
                mousemove: function(event) {
                    var internalWidth = parseInt(ig.system.canvas.offsetWidth) || ig.system.realWidth;
                    var scale = ig.system.scale * (internalWidth / ig.system.realWidth);
                    var pos = {
                        left: 0,
                        top: 0
                    };
                    if (ig.system.canvas.getBoundingClientRect) {
                        pos = ig.system.canvas.getBoundingClientRect();
                    }
                    var ev = event.touches ? event.touches[0] : event;
                    this.mouse.x = (ev.pageX - ig.CanvasCSS3Scaling.offset[0]) / ig.CanvasCSS3Scaling.scale;
                    this.mouse.y = (ev.pageY - ig.CanvasCSS3Scaling.offset[1]) / ig.CanvasCSS3Scaling.scale;
                }
            });
        },
        reflow: function() {
            var browser = [window.innerWidth, window.innerHeight];
            var scale = this.scale = Math.min(browser[0] / this.content[0], browser[1] / this.content[1]);
            var size = [this.content[0] * scale, this.content[1] * scale];
            var offset = this.offset = [(browser[0] - size[0]) / 2, (browser[1] - size[1]) / 2];
            var rule = "translate(" + offset[0] + "px, " + offset[1] + "px) scale(" + scale + ")";
            this.element.style.transform = rule;
            this.element.style.webkitTransform = rule;
        },
        handleEvent: function(evt) {
            if (evt.type == 'resize' || evt.type == 'orientationchange') {
                this.reflow();
            }
        }
    });
});

// lib/plugins/impact-storage.js
ig.baked = true;
ig.module('plugins.impact-storage').requires('impact.game').defines(function() {
    ig.Storage = ig.Class.extend({
        staticInstantiate: function(i) {
            return !ig.Storage.instance ? null : ig.Storage.instance;
        },
        init: function() {
            ig.Storage.instance = this;
        },
        isCapable: function() {
            return !(typeof(window.localStorage) === 'undefined');
        },
        isSet: function(key) {
            return !(this.get(key) === null);
        },
        initUnset: function(key, value) {
            if (this.get(key) === null) this.set(key, value);
        },
        get: function(key) {
            if (!this.isCapable()) return null;
            try {
                return JSON.parse(localStorage.getItem(key));
            } catch (e) {
                return window.localStorage.getItem(key);
            }
        },
        getInt: function(key) {
            return ~~this.get(key);
        },
        getFloat: function(key) {
            return parseFloat(this.get(key));
        },
        getBool: function(key) {
            return !!this.get(key);
        },
        key: function(n) {
            return this.isCapable() ? window.localStorage.key(n) : null;
        },
        set: function(key, value) {
            if (!this.isCapable()) return null;
            try {
                window.localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                if (e == QUOTA_EXCEEDED_ERR)
                    console.log('localStorage quota exceeded');
            }
        },
        setHighest: function(key, value) {
            if (value > this.getFloat(key)) this.set(key, value);
        },
        remove: function(key) {
            if (!this.isCapable()) return null;
            window.localStorage.removeItem(key);
        },
        clear: function() {
            if (!this.isCapable()) return null;
            window.localStorage.clear();
        }
    });
});

// lib/rogers.js
ig.baked = true;
ig.module('rogers').requires('impact.game', 'impact.entity', 'impact.font', 'plugins.parallax', 'plugins.impact-splash-loader', 'plugins.canvas-css3-scaling', 'plugins.impact-storage').defines(function() {
    var _LANG_CODE, _LANG_STRING;
    getOrRefreshLanguage = function() {
        _LANG_CODE = document.webL10n.getLanguage() || 'en';
        if (!_LANG_SIZES[_LANG_CODE]) {
            _LANG_CODE = 'en';
        }
        _LANG_STRING = 'lang/' + _LANG_CODE + '/';
    }
    var _LANG_SIZES = {
        'en': {
            'shield': {
                x: 100,
                y: 20
            },
            'score': {
                x: 150,
                y: 20
            }
        },
        'es': {
            'shield': {
                x: 105,
                y: 20
            },
            'score': {
                x: 168,
                y: 20
            }
        },
        'pt': {
            'shield': {
                x: 105,
                y: 20
            },
            'score': {
                x: 170,
                y: 20
            }
        },
        'tr': {
            'shield': {
                x: 102,
                y: 20
            },
            'score': {
                x: 143,
                y: 20
            }
        },
        'cs': {
            'shield': {
                x: 92,
                y: 20
            },
            'score': {
                x: 150,
                y: 20
            }
        },
        'ja': {
            'shield': {
                x: 83,
                y: 20
            },
            'score': {
                x: 146,
                y: 20
            }
        }
    };
    _LANG_LIST = ['en', 'es', 'pt', 'tr', 'cs', 'ja'];
    getOrRefreshLanguage();
    var animSheetList = {
        buttonBack: {},
        buttonContinue: {},
        buttonRestart: {},
        buttonStart: {},
        buttonContinueImg: {},
        gameoverBest: {},
        gameoverHighscore: {},
        gameoverScore: {},
        screenGamecompleted: {},
        screenGameOverAsteroid: {},
        screenGameOverMine: {},
        screenGameOverOffscreen: {},
        screenHowto: {},
        screenPause: {},
        screenStory: {},
        UIScore: {},
        UIShield: {}
    };
    for (var l = 0; l < _LANG_LIST.length; l++) {
        var lang = _LANG_LIST[l];
        animSheetList.buttonBack[lang] = new ig.AnimationSheet('media/img/lang/' + lang + '/button-back.png', 186, 58);
        animSheetList.buttonContinue[lang] = new ig.AnimationSheet('media/img/lang/' + lang + '/button-continue.png', 132, 43);
        animSheetList.buttonRestart[lang] = new ig.AnimationSheet('media/img/lang/' + lang + '/button-restart.png', 186, 58);
        animSheetList.buttonStart[lang] = new ig.AnimationSheet('media/img/lang/' + lang + '/button-start.png', 181, 60);
        animSheetList.buttonContinueImg[lang] = new ig.Image('media/img/lang/' + lang + '/button-continue.png');
        animSheetList.gameoverBest[lang] = new ig.Image('media/img/lang/' + lang + '/gameover-best.png');
        animSheetList.gameoverHighscore[lang] = new ig.Image('media/img/lang/' + lang + '/gameover-highscore.png');
        animSheetList.gameoverScore[lang] = new ig.Image('media/img/lang/' + lang + '/gameover-score.png');
        animSheetList.screenGamecompleted[lang] = new ig.Image('media/img/lang/' + lang + '/screen-gamecompleted.png');
        animSheetList.screenGameOverAsteroid[lang] = new ig.Image('media/img/lang/' + lang + '/screen-gameover-asteroid.png');
        animSheetList.screenGameOverMine[lang] = new ig.Image('media/img/lang/' + lang + '/screen-gameover-mine.png');
        animSheetList.screenGameOverOffscreen[lang] = new ig.Image('media/img/lang/' + lang + '/screen-gameover-offscreen.png');
        animSheetList.screenHowto[lang] = new ig.Image('media/img/lang/' + lang + '/screen-howto.png');
        animSheetList.screenPause[lang] = new ig.Image('media/img/lang/' + lang + '/screen-pause.png');
        animSheetList.screenStory[lang] = new ig.Image('media/img/lang/' + lang + '/screen-story.png');
        animSheetList.UIScore[lang] = new ig.AnimationSheet('media/img/lang/' + lang + '/ui-score.png', _LANG_SIZES[lang]['score'].x, _LANG_SIZES[lang]['score'].y);
        animSheetList.UIShield[lang] = new ig.AnimationSheet('media/img/lang/' + lang + '/ui-shield.png', _LANG_SIZES[lang]['shield'].x, _LANG_SIZES[lang]['shield'].y);
    };
    EntityAsteroid = ig.Entity.extend({
        sizes: [16, 21, 32, 42, 47],
        damage: [10, 10, 20, 30, 30],
        num: 0,
        speed: 0,
        maxVel: {
            x: 0,
            y: 0
        },
        type: ig.Entity.TYPE.B,
        sound: new ig.Sound('media/audio/asteroid-hit.*'),
        init: function(x, y, settings) {
            this.num = Math.floor(Math.random() * this.sizes.length);
            var actualSize = this.sizes[this.num];
            this.size = {
                x: actualSize,
                y: actualSize
            };
            this.animSheet = new ig.AnimationSheet('media/img/asteroid-' + actualSize + '.png', actualSize, actualSize);
            var animationTable = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
            if (Math.random() < 0.5) {
                animationTable.reverse();
            }
            this.addAnim('rotate', 0.07, animationTable);
            this.parent(x, y, settings);
            this.speed = ig.game.speed + Math.random() * ig.game.speed - Math.random() * ig.game.speed;
        },
        update: function() {
            this.parent();
            if (this.pos.x - ig.game.screen.x < -50) {
                this.kill();
            }
        },
        check: function(other) {
            // console.log("Ship collides with Asteroid")
            if(ig.game.sgameFlag === true){
                return;
            }
            ig.game.sgameFlag = true;
            ig.game.gamePaused = true;
            var that = this;

            SGAME.triggerLO(1,function(pass){
                ig.game.player.vel.y = 0;
                if(typeof ig.game.BtnBack !== "undefined"){
                    ig.game.BtnBack.kill();
                }
                if(typeof ig.game.BtnRestart !== "undefined"){
                    ig.game.BtnRestart.kill();
                }
                ig.game.gamePaused = false;
                
                setTimeout(function(){
                    if(!pass){
                        ig.game.player.receiveDamage(that.damage[that.num], that);
                    }

                    ig.game.UIShield.currentAnim = ig.game.UIShield.anims[ig.game.player.health.floor().toString()];
                    if (ig.game.player.health <= 0) {
                        ig.game.gameOverType = 'asteroid';
                    }
                    if (ig.Sound.enabled)
                        that.sound.play();
                    that.kill();

                    ig.game.sgameFlag = false;
                },50);
            });
        },
        kill: function() {
            if (this.pos.x + 50 > 0) {
                if (ig.game.BtnBomb && ig.game.BtnBomb.bombingInProgress) {
                    ig.game.spawnEntity(EntityAsteroidExplosion, this.pos.x - 42, this.pos.y - 42);
                } else {
                    ig.game.spawnEntity(EntityAsteroidExplosion, ig.game.player.pos.x, ig.game.player.pos.y - 40);
                }
            }
            this.parent();
        }
    });
    EntityAsteroidExplosion = ig.Entity.extend({
        lifetime: 0.3,
        size: {
            x: 1,
            y: 1
        },
        maxVel: {
            x: 0,
            y: 0
        },
        animSheet: new ig.AnimationSheet('media/img/asteroid-explosion.png', 93, 96),
        type: ig.Entity.TYPE.NONE,
        init: function(x, y, settings) {
            this.addAnim('hit', 0.03, [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);
            this.addAnim('bomb', 0.03, [23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10]);
            this.parent(x, y, settings);
            this.idleTimer = new ig.Timer();
            this.currentAnim = (ig.game.BtnBomb && ig.game.BtnBomb.bombingInProgress) ? this.anims['bomb'] : this.anims['hit'];
        },
        update: function() {
            if (this.idleTimer.delta() > this.lifetime) {
                this.kill();
                return;
            }
            this.parent();
        }
    });
    EntityButton = ig.Entity.extend({
        sound: new ig.Sound('media/audio/button-click.*'),
        init: function(x, y, settings) {
            this.addAnim('idle', 0.1, [0]);
            this.parent(x, y, settings);
        },
        inFocus: function() {
            return ((this.pos.x <= (ig.input.mouse.x + ig.game.screen.x)) && ((ig.input.mouse.x + ig.game.screen.x) <= this.pos.x + this.size.x) && (this.pos.y <= (ig.input.mouse.y + ig.game.screen.y)) && ((ig.input.mouse.y + ig.game.screen.y) <= this.pos.y + this.size.y));
        }
    });
    EntityButtonEnclave = EntityButton.extend({
        size: {
            x: 100,
            y: 41
        },
        animSheet: new ig.AnimationSheet('media/img/button-enclave.png', 100, 41),
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled)
                    this.sound.play();
                window.top.location.href = 'http://enclavegames.com';
            }
        }
    });
    EntityButtonBlackmoon = EntityButton.extend({
        size: {
            x: 35,
            y: 40
        },
        animSheet: new ig.AnimationSheet('media/img/button-blackmoon.png', 35, 40),
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled)
                    this.sound.play();
                window.top.location.href = 'http://blackmoondev.com';
            }
        }
    });
    EntityButtonStart = EntityButton.extend({
        size: {
            x: 181,
            y: 60
        },
        animSheet: animSheetList.buttonStart[_LANG_CODE],
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled) {
                    this.sound.play();
                }
                ig.system.setGame(StoryScreen);
            }
        }
    });
    EntityButtonPause = EntityButton.extend({
        size: {
            x: 42,
            y: 44
        },
        animSheet: new ig.AnimationSheet('media/img/button-pause.png', 42, 44),
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled)
                    this.sound.play();
                ig.game.gamePaused = !ig.game.gamePaused;
            }
        }
    });
    EntityButtonBomb = EntityButton.extend({
        size: {
            x: 42,
            y: 44
        },
        animSheet: new ig.AnimationSheet('media/img/button-bomb.png', 42, 44),
        sound: new ig.Sound('media/audio/asteroid-hit.*'),
        bombingInProgress: false,
        init: function(x, y, settings) {
            this.addAnim('active', 0.1, [0]);
            this.addAnim('inactive', 0.1, [1]);
            this.parent(x, y, settings);
            this.currentAnim = this.anims['active'];
        },
        update: function() {
            if ((ig.input.pressed('click') && this.inFocus()) || ig.game.activateBombing) {
                if (this.currentAnim == this.anims['active']) {
                    this.bombingInProgress = true;
                    if (ig.Sound.enabled)
                        this.sound.play();
                    for (var i = 0; i < ig.game.entities.length; i++) {
                        if (ig.game.entities[i].type == ig.Entity.TYPE.B)
                            ig.game.entities[i].kill();
                    }
                    this.currentAnim = this.anims['inactive'];
                    ig.game.activateBombing = false;
                    ig.game.BtnBomb.bombingInProgress = false;
                }
            }
        }
    });
    EntityButtonAudio = EntityButton.extend({
        size: {
            x: 42,
            y: 44
        },
        animSheet: new ig.AnimationSheet('media/img/button-audio.png', 42, 44),
        init: function(x, y, settings) {
            this.addAnim('true', 0.1, [0]);
            this.addAnim('false', 0.1, [1]);
            this.parent(x, y, settings);
        },
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (!ig.ua.iOS) {
                    ig.Sound.enabled = !ig.Sound.enabled;
                    if (ig.game.storage.isCapable())
                        ig.game.storage.set('rogers-audio', ig.Sound.enabled);
                    this.currentAnim = this.anims[(ig.Sound.enabled).toString()];
                    if (ig.Sound.enabled) {
                        ig.music.play();
                        this.sound.play();
                    } else {
                        ig.music.pause();
                    }
                }
            }
        }
    });
    EntityButtonFacebook = EntityButton.extend({
        size: {
            x: 66,
            y: 69
        },
        animSheet: new ig.AnimationSheet('media/img/button-facebook.png', 66, 69),
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled)
                    this.sound.play();
                window.top.location.href = 'https://www.facebook.com/CaptainRogersChronicles';
            }
        }
    });
    EntityButtonBack = EntityButton.extend({
        size: {
            x: 186,
            y: 58
        },
        animSheet: animSheetList.buttonBack[_LANG_CODE],
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if(ig.game.sgameFlag !== true){
                    if (ig.Sound.enabled)
                        this.sound.play();
                    ig.system.setGame(StartScreen);
                }
            }
        }
    });
    EntityButtonContinue = EntityButton.extend({
        size: {
            x: 132,
            y: 43
        },
        animSheet: animSheetList.buttonContinue[_LANG_CODE],
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled)
                    this.sound.play();
            }
        }
    });
    EntityButtonContinueHowTo = EntityButton.extend({
        size: {
            x: 132,
            y: 43
        },
        animSheet: animSheetList.buttonContinue[_LANG_CODE],
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled)
                    this.sound.play();
                ig.system.setGame(HowToScreen);
            }
        }
    });
    EntityButtonContinueGame = EntityButton.extend({
        size: {
            x: 132,
            y: 43
        },
        animSheet: animSheetList.buttonContinue[_LANG_CODE],
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if (ig.Sound.enabled)
                    this.sound.play();
                ig.system.setGame(RogersGame);
            }
        }
    });
    EntityButtonRestart = EntityButton.extend({
        size: {
            x: 186,
            y: 58
        },
        animSheet: animSheetList.buttonRestart[_LANG_CODE],
        update: function() {
            if (ig.input.pressed('click') && this.inFocus()) {
                if(ig.game.sgameFlag !== true){
                    if (ig.Sound.enabled)
                        this.sound.play();
                    this.gameOverRunOnce = false;
                    ig.system.setGame(RogersGame);
                }
            }
        }
    });
    EntityItemShield = ig.Entity.extend({
        size: {
            x: 28,
            y: 23
        },
        maxVel: {
            x: 0,
            y: 0
        },
        animSheet: new ig.AnimationSheet('media/img/shield.png', 28, 23),
        type: ig.Entity.TYPE.B,
        sound: new ig.Sound('media/audio/shield-collect.*'),
        init: function(x, y, settings) {
            this.addAnim('idle', 0.1, [0]);
            this.parent(x, y, settings);
        },
        update: function() {
            this.parent();
            if (this.pos.x - ig.game.screen.x < -this.size.x) {
                this.kill();
            }
        },
        check: function(other) {
            // console.log("Ship collides with shield")
            if(ig.game.sgameFlag === true){
                return;
            }
            ig.game.sgameFlag = true;
            ig.game.gamePaused = true;
            var that = this;

            SGAME.triggerLO(2,function(pass){
                ig.game.player.vel.y = 0;
                if(typeof ig.game.BtnBack !== "undefined"){
                    ig.game.BtnBack.kill();
                }
                if(typeof ig.game.BtnRestart !== "undefined"){
                    ig.game.BtnRestart.kill();
                }
                ig.game.gamePaused = false;
                
                setTimeout(function(){
                    if(pass){
                        ig.game.player.health += 20;
                        if (ig.game.player.health > ig.game.player.maxHealth) {
                            ig.game.player.health = ig.game.player.maxHealth;
                        }
                    }

                    ig.game.UIShield.currentAnim = ig.game.UIShield.anims[ig.game.player.health.floor().toString()];
                    if (ig.Sound.enabled)
                        that.sound.play();
                    that.kill();

                    ig.game.sgameFlag = false;
                },50);
            });  
        }
    });
    EntityItemBomb = ig.Entity.extend({
        size: {
            x: 28,
            y: 23
        },
        maxVel: {
            x: 0,
            y: 0
        },
        animSheet: new ig.AnimationSheet('media/img/bomb.png', 28, 23),
        type: ig.Entity.TYPE.B,
        sound: new ig.Sound('media/audio/shield-collect.*'),
        init: function(x, y, settings) {
            this.addAnim('idle', 0.1, [0]);
            this.parent(x, y, settings);
        },
        update: function() {
            this.parent();
            if (this.pos.x - ig.game.screen.x < -this.size.x) {
                this.kill();
            }
        },
        check: function(other) {
            ig.game.BtnBomb.currentAnim = ig.game.BtnBomb.anims['active'];
            if (ig.Sound.enabled)
                this.sound.play();
            this.kill();
        }
    });
    EntityItemStar = ig.Entity.extend({
        size: {
            x: 26,
            y: 26
        },
        maxVel: {
            x: 0,
            y: 0
        },
        animSheet: new ig.AnimationSheet('media/img/star.png', 26, 26),
        type: ig.Entity.TYPE.B,
        sound: new ig.Sound('media/audio/bonus-collect.*'),
        init: function(x, y, settings) {
            this.addAnim('rotate', 0.1, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
            this.parent(x, y, settings);
        },
        update: function() {
            this.parent();
            if (this.pos.x - ig.game.screen.x < -this.size.x) {
                this.kill();
            }
        },
        check: function(other) {
            ig.game.score += 200;
            if (ig.Sound.enabled)
                this.sound.play();
            this.kill();
        }
    });
    EntityItemMine = ig.Entity.extend({
        size: {
            x: 32,
            y: 32
        },
        maxVel: {
            x: 0,
            y: 0
        },
        direction: 0,
        animSheet: new ig.AnimationSheet('media/img/mine.png', 32, 32),
        type: ig.Entity.TYPE.B,
        init: function(x, y, settings) {
            this.addAnim('idle', 0.1, [0]);
            this.parent(x, y, settings);
            this.direction = ((Math.floor((Math.random() * 2)) * 2) - 1);
        },
        update: function() {
            this.parent();
            if (this.pos.x - ig.game.screen.x < -this.size.x) {
                this.kill();
            }
            if (this.pos.y > ig.system.height - this.size.y || this.pos.y < 0) {
                this.direction = -this.direction;
            }
            this.pos.y += this.direction;
        },
        check: function(other) {
            this.kill();
            ig.game.gameOverType = 'mine';
            ig.game.player.kill();
        }
    });
    EntityUIShield = ig.Entity.extend({
        size: {
            x: _LANG_SIZES[_LANG_CODE]['shield'].x,
            y: _LANG_SIZES[_LANG_CODE]['shield'].y
        },
        maxVel: {
            x: 0,
            y: 0
        },
        animSheet: animSheetList.UIShield[_LANG_CODE],
        type: ig.Entity.TYPE.NONE,
        init: function(x, y, settings) {
            this.addAnim('10', 0.1, [0]);
            this.addAnim('20', 0.1, [1]);
            this.addAnim('30', 0.1, [2]);
            this.addAnim('40', 0.1, [3]);
            this.addAnim('50', 0.1, [4]);
            this.addAnim('60', 0.1, [5]);
            this.addAnim('70', 0.1, [6]);
            this.addAnim('80', 0.1, [7]);
            this.addAnim('90', 0.1, [8]);
            this.addAnim('100', 0.1, [9]);
            this.currentAnim = this.anims['100'];
            this.parent(x, y, settings);
        },
        update: function() {
            this.parent();
        }
    });
    EntityUIScore = ig.Entity.extend({
        font: new ig.Font('media/telemarines.font.png'),
        size: {
            x: _LANG_SIZES[_LANG_CODE]['score'].x,
            y: _LANG_SIZES[_LANG_CODE]['score'].y
        },
        maxVel: {
            x: 0,
            y: 0
        },
        animSheet: animSheetList.UIScore[_LANG_CODE],
        type: ig.Entity.TYPE.NONE,
        init: function(x, y, settings) {
            this.addAnim('idle', 0.1, [0]);
            this.parent(x, y, settings);
        },
        update: function() {
            this.parent();
        },
        draw: function() {
            this.parent();
            this.font.draw(ig.game.score.floor().toString(), ig.system.width - 60 - 52, 10, ig.Font.ALIGN.RIGHT);
        }
    });
    EntityPlayer = ig.Entity.extend({
        health: 100,
        maxHealth: 100,
        size: {
            x: 50,
            y: 30
        },
        offset: {
            x: 20,
            y: 30
        },
        type: ig.Entity.TYPE.NONE,
        checkAgainst: ig.Entity.TYPE.B,
        animSheet: new ig.AnimationSheet('media/img/player.png', 82, 74),
        maxVel: {
            x: 0,
            y: 110
        },
        friction: {
            x: 0,
            y: 225
        },
        speed: 200,
        ascend: 140,
        sound: new ig.Sound('media/audio/player-engines.*'),
        soundLifetime: 1,
        init: function(x, y, settings) {
            this.addAnim('up', 0.025, [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]);
            this.addAnim('idle', 0.025, [7, 8, 9, 10, 11, 12, 13, 12, 11, 10, 9, 8]);
            this.parent(x, y, settings);
            this.soundTimer = new ig.Timer();
        },
        update: function() {
            if (ig.input.state('up') || ig.input.state('click')) {
                if (ig.game.player.pos.y > ig.game.screen.y) {
                    if (ig.Sound.enabled && this.soundTimer.delta() >= 0) {
                        this.sound.play();
                        this.soundTimer.set(this.soundLifetime);
                    }
                    this.vel.y = -this.ascend;
                    this.currentAnim = this.anims.up;
                }
            } else {
                this.currentAnim = this.anims.idle;
            }
            this.parent();
        },
        check: function(other) {
            other.check();
        },
        kill: function() {
            ig.game.spawnEntity(EntityPlayerExplosion, ig.game.player.pos.x - 70, ig.game.player.pos.y - 90, {
                callBack: this.onDeath
            });
            this.parent();
        },
        onDeath: function() {
            ig.game.gameOver = true;
        }
    });
    EntityPlayerExplosion = ig.Entity.extend({
        lifetime: 1.5,
        callBack: null,
        size: {
            x: 1,
            y: 1
        },
        maxVel: {
            x: 0,
            y: 0
        },
        animSheet: new ig.AnimationSheet('media/img/player-explosion.png', 174, 208),
        type: ig.Entity.TYPE.NONE,
        sound: new ig.Sound('media/audio/player-explosion.*'),
        init: function(x, y, settings) {
            this.addAnim('kaboom', 0.03, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
            this.parent(x, y, settings);
            this.idleTimer = new ig.Timer();
            if (ig.Sound.enabled)
                this.sound.play();
        },
        update: function() {
            if (this.idleTimer.delta() > this.lifetime) {
                this.kill();
                if (this.callBack) {
                    this.callBack();
                }
                return;
            }
            this.parent();
        },
        draw: function() {
            this.pos.x = ig.game.screen.x;
            this.parent();
        }
    });
    RogersGame = ig.Game.extend({
        clearColor: null,
        gravity: 350,
        player: null,
        gameOver: false,
        gameOverType: null,
        gamePaused: false,
        gameCompleted: false,
        sgameFlag: false,
        maxScore: 20000,
        score: 0,
        speed: 1.5,
        seconds: null,
        secondsTimer: null,
        gameOverRunOnce: false,
        font: new ig.Font('media/telemarines.font.png'),
        background: new ig.Image('media/img/deepspace.png'),
        stars: new ig.Image('media/img/stars.png'),
        gameOverScreenAsteroid: animSheetList.screenGameOverAsteroid[_LANG_CODE],
        gameOverScreenMine: animSheetList.screenGameOverMine[_LANG_CODE],
        gameOverScreenOffscreen: animSheetList.screenGameOverOffscreen[_LANG_CODE],
        gameOverScore: animSheetList.gameoverScore[_LANG_CODE],
        gameOverBest: animSheetList.gameoverBest[_LANG_CODE],
        gameOverHighscore: animSheetList.gameoverHighscore[_LANG_CODE],
        gamePausedScreen: animSheetList.screenPause[_LANG_CODE],
        gameCompletedScreen: animSheetList.screenGamecompleted[_LANG_CODE],
        storage: new ig.Storage(),
        parallax: null,
        bombsCount: 0,
        activateBombing: false,
        init: function() {
            ig.input.bind(ig.KEY.UP_ARROW, 'up');
            ig.input.bind(ig.KEY.MOUSE1, 'click');
            ig.input.bind(ig.KEY.ENTER, 'ok');
            ig.input.bind(ig.KEY.P, 'pause');
            ig.input.bind(ig.KEY.B, 'bomb');
            ig.input.bind(ig.KEY.C, 'cheat code');
            this.secondsTimer = new ig.Timer(1);
            this.gameOverRunOnce = false;
            this.parallax = new Parallax();
            this.parallax.add(this.background.path, {
                distance: 5,
                y: 0
            });
            this.parallax.add(this.stars.path, {
                distance: 2,
                y: 0
            });
            this.player = this.spawnEntity(EntityPlayer, 40, 72);
            this.UIShield = this.spawnEntity(EntityUIShield, 55, 5);
            this.UIScore = this.spawnEntity(EntityUIScore, ig.system.width - 205 - 47 - 5, 5);
            this.BtnPause = this.spawnEntity(EntityButtonPause, ig.system.width - 47 - 47 - 5, 5);
            this.BtnAudio = this.spawnEntity(EntityButtonAudio, ig.system.width - 47, 5);
            this.BtnBomb = this.spawnEntity(EntityButtonBomb, 5, 5);
            if (ig.Sound.enabled) {
                this.BtnAudio.currentAnim = this.BtnAudio.anims['true'];
            } else {
                this.BtnAudio.currentAnim = this.BtnAudio.anims['false'];
            }
            this.newItemTable();
            ig.game.player.vel.y = 0;
            this.oldHighscore = ig.game.storage.get('rogers-highscore');
            this.settingTheScore = false;
        },
        placeEntity: function(entity) {
            var x = ig.system.width + 50;
            var y = Math.random() * ig.system.height;
            var item = this.spawnEntity(entity, x, y);
            item.speed = ig.game.speed + Math.random() * ig.game.speed / 2 - Math.random() * ig.game.speed / 2;
            if (y > ig.system.height - item.size.y)
                item.pos.y = ig.system.height - item.size.y;
        },
        shuffleArray: function(array) {
            var len = array.length;
            var i = len;
            while (i--) {
                var p = parseInt(Math.random() * len);
                var t = array[i];
                array[i] = array[p];
                array[p] = t;
            }
        },
        newItemTable: function() {
            this.entityItemTable = [];
            this.entityItemTable.push(EntityItemMine);
            this.entityItemTable.push(EntityItemStar);
            this.entityItemTable.push(EntityItemShield);
            this.entityItemTable.push(EntityItemMine);
            this.entityItemTable.push(EntityItemStar);
            this.entityItemTable.push(EntityItemShield);
            this.entityItemTable.push(EntityItemBomb);
            for (var i = 0; i < 33; i++) {
                this.entityItemTable.push(EntityAsteroid);
            }
            this.shuffleArray(this.entityItemTable);
        },
        update: function() {
            if (this.score >= this.maxScore) {
                if (!this.BtnCompleted) {
                    this.BtnCompleted = this.spawnEntity(EntityButtonBack, ig.system.width - 186 - 10, ig.system.height - 58 - 10);
                }
                this.BtnCompleted.update();
            } else if (this.gamePaused) {
                if (!this.BtnRestart)
                    this.BtnRestart = this.spawnEntity(EntityButtonRestart, 10, ig.system.height - 58 - 10);
                if (!this.BtnBack)
                    this.BtnBack = this.spawnEntity(EntityButtonBack, ig.system.width - 186 - 10, ig.system.height - 58 - 10);
                this.BtnRestart.update();
                this.BtnBack.update();
                if (ig.input.pressed('click')) {
                    if(ig.game.sgameFlag !== true){
                        this.gamePaused = false;
                        ig.game.player.vel.y = 0;
                        this.BtnBack.kill();
                        this.BtnRestart.kill();
                    }
                }
            } else if (this.gameOver) {
                if (!this.BtnRestart)
                    this.BtnRestart = this.spawnEntity(EntityButtonRestart, 10, ig.system.height - 58 - 10);
                if (!this.BtnBack)
                    this.BtnBack = this.spawnEntity(EntityButtonBack, ig.system.width - 186 - 10, ig.system.height - 58 - 10);
                if (!this.BtnAudio)
                    this.BtnAudio = this.spawnEntity(EntityButtonAudio, ig.system.width - 47, 5);
                this.BtnRestart.update();
                this.BtnBack.update();
                this.BtnAudio.update();
                var newHighscore = (this.score).floor();
                if (newHighscore > this.oldHighscore && !this.settingTheScore) {
                    ig.game.storage.setHighest('rogers-highscore', newHighscore);
                    this.settingTheScore = true;
                }
            } else {
                if (ig.input.pressed('ok')) {
                    ig.system.setGame(RogersGame);
                } else {
                    if (ig.input.pressed('pause')) {
                        this.gamePaused = !this.gamePaused;
                    }
                    if (ig.input.pressed('bomb')) {
                        this.activateBombing = true;
                    }
                    if (ig.input.pressed('cheat code')) {
                        this.activateBombing = false;
                        this.BtnBomb.currentAnim = this.BtnBomb.anims['active'];
                        this.player.health = 100;
                        this.UIShield.currentAnim = this.UIShield.anims['100'];
                    }
                    this.speed += 0.0005;
                    this.score += ig.system.tick * this.speed * 5;
                    for (var i = 0; i < this.entities.length; i++) {
                        if (this.entities[i].type == ig.Entity.TYPE.B)
                            this.entities[i].pos.x -= this.entities[i].speed;
                    }
                    this.tickCount = Math.ceil(this.score / 1000);
                    if (this.secondsTimer.delta() > 0) {
                        ig.game.seconds++;
                        this.secondsTimer.reset();
                        for (var i = 0; i < this.tickCount; i++) {
                            if (!this.entityItemTable.length) {
                                this.newItemTable();
                            }
                            this.placeEntity(this.entityItemTable.pop());
                        }
                    }
                    this.parallax.move(40 * this.speed);
                    this.parent();
                    if (this.player.pos.y > ig.system.height + this.player.size.y) {
                        this.gameOver = true;
                        this.gameOverType = 'offscreen';
                    }
                }
            }
        },
        draw: function() {
            if (this.score >= this.maxScore) {
                this.gameCompletedScreen.draw(0, 0);
                if (this.BtnCompleted)
                    this.BtnCompleted.draw();
            } else if (this.gamePaused) {
                this.gamePausedScreen.draw(0, 0);
                if (this.BtnRestart)
                    this.BtnRestart.draw();
                if (this.BtnBack)
                    this.BtnBack.draw();
            } else if (this.gameOver) {
                if (!this.gameOverRunOnce) {
                    var x = (ig.system.width - 254) / 2;
                    var y = ((ig.system.height - 147) / 2) - 30;
                    switch (this.gameOverType) {
                        case 'offscreen':
                            {
                                this.gameOverScreenOffscreen.draw(x, y);
                                break;
                            }
                        case 'asteroid':
                            {
                                this.gameOverScreenAsteroid.draw(x, y);
                                break;
                            }
                        case 'mine':
                            {
                                this.gameOverScreenMine.draw(x, y);
                                break;
                            }
                        default:
                            {}
                    }
                    if (this.BtnRestart)
                        this.BtnRestart.draw();
                    if (this.BtnBack)
                        this.BtnBack.draw();
                    this.gameOverScore.draw(10, 80);
                    this.gameOverBest.draw(ig.system.width - 10 - 121, 80);
                    this.font.draw(this.score.floor().toString(), 115, 113, ig.Font.ALIGN.RIGHT);
                    var highscore = this.oldHighscore;
                    if (this.score > this.oldHighscore) {
                        this.gameOverHighscore.draw(ig.system.width - 22 - 96, 142);
                        var highscore = this.score.floor().toString();
                    }
                    this.font.draw(highscore, ig.system.width - 22, 112, ig.Font.ALIGN.RIGHT);
                    if (this.BtnRestart && this.BtnBack && this.BtnAudio) {
                        this.gameOverRunOnce = true;
                    }
                }
                if (this.BtnAudio)
                    this.BtnAudio.draw();
            } else {
                this.parallax.draw();
                this.parent();
                this.UIShield.draw();
                this.UIScore.draw();
                this.BtnPause.draw();
                this.BtnAudio.draw();
                this.BtnBomb.draw();
            }
        }
    });
    StartScreen = ig.Game.extend({
        clearColor: null,
        font: new ig.Font('media/telemarines.font.png'),
        background: new ig.Image('media/img/deepspace.png'),
        stars: new ig.Image('media/img/stars.png'),
        ship: new ig.Image('media/img/cover-ship.png'),
        logo: new ig.Image('media/img/cover-logo.png'),
        title: new ig.Image('media/img/cover-title.png'),
        bestScore: animSheetList.gameoverBest[_LANG_CODE],
        storage: new ig.Storage(),
        counter: 0,
        parallax: null,
        init: function() {
            getOrRefreshLanguage();
            this.storage.initUnset('rogers-highscore', 0);
            ig.input.bind(ig.KEY.SPACE, 'start');
            ig.input.bind(ig.KEY.ENTER, 'start');
            ig.input.bind(ig.KEY.MOUSE1, 'click');
            ig.input.bind(ig.KEY.H, 'howTo');
            this.parallax = new Parallax();
            this.parallax.add(this.background.path, {
                distance: 5,
                y: 0
            });
            this.parallax.add(this.stars.path, {
                distance: 2,
                y: 0
            });
            this.BtnStart = this.spawnEntity(EntityButtonStart, ig.system.width - 183 - 10, ig.system.height - 60 - 10);
            this.BtnFacebook = this.spawnEntity(EntityButtonFacebook, ig.system.width - 66 - 10, 10);
            this.BtnAudio = this.spawnEntity(EntityButtonAudio, ig.system.width - 130, 10);
            this.BtnBlackmoon = this.spawnEntity(EntityButtonBlackmoon, 10, 10);
            this.BtnEnclave = this.spawnEntity(EntityButtonEnclave, 55, 10);
            if (!ig.ua.iOS && ig.game.storage.isCapable()) {
                ig.Sound.enabled = ig.game.storage.get('rogers-audio');
            }
            ig.music.add('media/audio/theme-music.*');
            ig.music.volume = 0.7;
            if (ig.Sound.enabled) {
                ig.music.play();
                this.BtnAudio.currentAnim = this.BtnAudio.anims['true'];
            } else {
                this.BtnAudio.currentAnim = this.BtnAudio.anims['false'];
            }
            this.oldHighscore = ig.game.storage.get('rogers-highscore');
        },
        update: function() {
            if (ig.input.pressed('start')) {
                ig.system.setGame(StoryScreen);
            } else if (ig.input.pressed('howTo')) {
                ig.system.setGame(HowToScreen);
            }
            this.counter++;
            this.parallax.move(40);
            this.parent();
        },
        draw: function() {
            this.parent();
            this.parallax.draw();
            this.BtnStart.draw();
            this.BtnEnclave.draw();
            this.BtnBlackmoon.draw();
            this.BtnFacebook.draw();
            this.BtnAudio.draw();
            var range = ((this.counter / 3) % 60) - 30;
            var delta = (range > 0) ? 1 : -1;
            var tick = range * delta;
            this.ship.draw(-30, ig.system.height - this.ship.height + tick + 10);
            this.logo.draw((ig.system.width - this.logo.width) / 2, 10);
            this.title.draw((ig.system.width - this.title.width + 160) / 2, 100);
            this.bestScore.draw(10, ig.system.height - 10 - 50);
            this.font.draw(this.oldHighscore, 70, ig.system.height - 28, ig.Font.ALIGN.CENTER);
        }
    });
    StoryScreen = ig.Game.extend({
        story: animSheetList.screenStory[_LANG_CODE],
        buttonContinue: animSheetList.buttonContinueImg[_LANG_CODE],
        init: function() {
            ig.input.bind(ig.KEY.SPACE, 'start');
            ig.input.bind(ig.KEY.ENTER, 'start');
            this.BtnContinue = this.spawnEntity(EntityButtonContinueHowTo, ig.system.width - 132 - 10, ig.system.height - 43 - 10);
        },
        update: function() {
            if (ig.input.pressed('start')) {
                ig.system.setGame(HowToScreen);
            }
            if (!this.BtnContinue)
                this.BtnContinue = this.spawnEntity(EntityButtonContinueHowTo, ig.system.width - 132 - 10, ig.system.height - 43 - 10);
            this.BtnContinue.update();
            this.parent();
        },
        draw: function() {
            this.parent();
            this.story.draw(0, 0);
            if (this.BtnContinue)
                this.BtnContinue.draw();
        }
    });
    HowToScreen = ig.Game.extend({
        howTo: animSheetList.screenHowto[_LANG_CODE],
        buttonContinue: animSheetList.buttonContinueImg[_LANG_CODE],
        init: function() {
            ig.input.bind(ig.KEY.SPACE, 'start');
            ig.input.bind(ig.KEY.ENTER, 'start');
            ig.input.bind(ig.KEY.H, 'howTo');
            this.BtnContinue = this.spawnEntity(EntityButtonContinueGame, ig.system.width - 132 - 10, ig.system.height - 43 - 10);
        },
        update: function() {
            if (ig.input.pressed('howTo')) {
                ig.system.setGame(StartScreen);
            }
            if (ig.input.pressed('start')) {
                ig.system.setGame(RogersGame);
            }
            if (!this.BtnContinue)
                this.BtnContinue = this.spawnEntity(EntityButtonContinueGame, ig.system.width - 132 - 10, ig.system.height - 43 - 10);
            this.BtnContinue.update();
            this.parent();
        },
        draw: function() {
            this.parent();
            this.howTo.draw(0, 0);
            if (this.BtnContinue)
                this.BtnContinue.draw();
        }
    });
    if (ig.ua.iOS) {
        ig.Sound.enabled = false;
    }
    checkOrientation = function() {
        if (ig.ua.mobile && (window.orientation == 0 || window.orientation == 180)) {
            document.getElementById('portrait').style.display = 'block';
            document.getElementById('game').style.display = 'none';
        } else {
            document.getElementById('portrait').style.display = 'none';
            document.getElementById('game').style.display = 'block';
        }
    }
    if (ig.ua.mobile && (window.orientation == 0 || window.orientation == 180)) {
        document.getElementById('portrait').style.display = 'block';
        document.getElementById('game').style.display = 'none';
    }

    function hideURLbar() {
        if (window.location.hash.indexOf('#') == -1) {
            window.scrollTo(0, 1);
        }
        ig.CanvasCSS3Scaling.reflow();
    }
    if (navigator.userAgent.indexOf('iPhone') != -1 || navigator.userAgent.indexOf('Android') != -1) {
        addEventListener("load", function() {
            setTimeout(hideURLbar, 0);
            setTimeout(ig.CanvasCSS3Scaling.reflow, 50);
        }, false);
    }
    window.addEventListener("orientationchange", checkOrientation);
    ig.CanvasCSS3Scaling = new CanvasCSS3Scaling();
    ig.CanvasCSS3Scaling.init();
    ig.main('#canvas', StartScreen, 30, 480, 320, 1, ig.ImpactSplashLoader);
});
(function() {
    function handleVisibilityChange() {
        if (document.hidden) {
            if (ig && ig.music && ig.Sound) {
                if (ig.Sound.enabled) {
                    ig.music.pause();
                }
            }
        } else {
            if (ig && ig.music && ig.Sound) {
                if (ig.Sound.enabled) {
                    ig.music.play();
                }
            }
        }
    }
    document.addEventListener("visibilitychange", handleVisibilityChange, false);
})();